## Apuntes de Fundamentos de la Programaci√≥n Orientado a Objetos
###### _No olvides darle una estrellita a este repositorio :D  -_ <img src="https://i.ibb.co/0nX0bNR/Screenshot-2024-05-07-164050.png" alt="Screenshot-2024-05-07-164050" border="0" height="30em" align="center">
###### Hay un archivo llamado **preguntas.md** en donde estan las posibles preguntas teoricas.
<img src="https://i.ibb.co/ryRMhP0/fpoo.png" alt="fpoo" border="0" height="370em"><br> 
##
# üü¢ SEMANA 01
### **üòµ‚Äçüí´ PROBLEMA Y SOLUCI√ìN**
<br>

| |
|---|
| **_"La programaci√≥n surge como respuesta a la necesidad de resolver problemas mediante la ejecuci√≥n de instrucciones por un ordenador"_**|

<br>

### **üìö CONCEPTO DE PROBLEMA**

Un problema en **t√©rminos generales** se puede conceptualizar de las siguientes maneras: 
- Es un asunto o cuesti√≥n que se debe solucionar o aclarar.
- Una contradicci√≥n o un conflicto entre lo que es y lo que debe ser.
- Una dificultad o un inconveniente para la consecuci√≥n de un fin.
- Un disgusto, una molestia o una preocupaci√≥n.
<br>

El  concepto de problema derivado de la Ingenier√≠a en su libro Introducci√≥n a la ingenier√≠a (1998) el autor **Krick afirma** que: <br>
| |
|---|
|**_‚ÄúUn problema proviene del deseo de lograr la transformaci√≥n de un estado en otro‚Äù_**| 
<br>

Ejemplo:
<br>
Si una persona est√° enferma **(Estado A)** , nace la necesidad o deseo de mejorar la salud; es decir
pasar a que esa persona est√© saludable **(Estado B)**, por medio de un tratamiento, operaci√≥n o
cualquier otra acci√≥n que produzca el cambio de estado. 
<br>
ejemplo 2:
<br>
Se necesita ense√±ar a ni√±os a cruzar la calle (**Estado A:** ni√±os no saben cruzar la calle) de una
manera entretenida y educativa (**Estado B:** los ni√±os aprendieron a cruzar la calle).

### **üß© PARTES DE UN PROBLEMA**
Todo problema est√° compuesto, conceptualmente, por tres partes o aspectos:
1. **Un estado inicial**, **‚ÄúA‚Äù** inferior, que se manifiesta por medio de s√≠ntomas, efectos o
consecuencias producto de una carencia, necesidad, deseo o expectativa que se desea
o requiere satisfacer. Esto es lo que el com√∫n de la gente denomina erradamente
problema, confundiendo los s√≠ntomas con las causas y con el verdadero problema.
Desde el punto de vista de quien tiene la necesidad o el deseo, esta fase se podr√≠a
denominar acertadamente **‚Äúsituaci√≥n problem√°tica‚Äù.**<br>

2. Un **estado final**, superior **‚ÄúB‚Äù**, el cual corresponde a la soluci√≥n del problema, a la
satisfacci√≥n de la necesidad o al valor agregado esperado. Alcanzar esta meta es el
objetivo principal de la disciplina de la ingenier√≠a en sus diferentes ramas, es decir, es
el ‚Äùque hacer‚Äù del ingeniero. El valor agregado de todos los proyectos y dise√±os de
ingenier√≠a se mide por el grado y la calidad alcanzados del estado *‚ÄùB‚Äù*.<br>

3. El proyecto, etapa que corresponde a las **estrategias** empleadas para darle soluci√≥n al
problema o para satisfacer la necesidad o el deseo planteado en la primera etapa. Es en
esta fase del problema donde el profesional aplica los conocimientos, habilidades y
destrezas adquiridas durante sus estudios profesionales, es decir, sus competencias en
el campo o problem√°tica respectiva.<br>

ejemplificaci√≥n de los estados A y B de un problema:

| ESTADO A | ESTRATEGIA | ESTADO B |
|-----------|-----------|-----------|
| Estudiante de Tec. Universitaria en Desarrollo Integral de Videojuegos  |‚üπ| T√©cnico/a Universitario/a en Dise√±o Integral de Videojuegos  |
| √Årbol  |‚üπ| Papel |
| Construcci√≥n Proyectada |‚üπ| Edificio terminado |
| Idea de videojuego  |‚üπ| Videojuego construido  |

### **‚¨õ Problema y Soluci√≥n desde una visi√≥n de ‚ÄúCaja Negra‚Äù** 
<br>

![image](https://github.com/AlexUnju/apuntes_fpoo/assets/142057928/2c615719-7ba4-4fa4-97e9-4ca3c173e74e)

##  VIDEO YOUTUBE PROBLEMA Y SOLUCION <img src="https://i.ibb.co/0Y8QBHD/yt.png" alt="yt" border="0" height="20"> <br>

[![Texto alternativo](https://img.youtube.com/vi/ickYKg0MyCk/maxresdefault.jpg)](https://www.youtube.com/watch?v=ickYKg0MyCk)

## **<img src="https://cdn-icons-png.flaticon.com/512/1448/1448776.png" height="25" align="left">PROGRAMACI√ìN**

Cuando la **estrategia** adoptada para obtener el estado deseado implica que los procesos sean
realizados por un ordenador; o dicho de otra manera cuando los sistemas utilizan procesos que
son llevados a cabo por un ordenador, entonces impl√≠citamente estos **sistemas recurrieron a la
programaci√≥n**.

### **üìö CONCEPTO DE PROGRAMACI√ìN**

El concepto de programaci√≥n abarca diferentes perspectivas en Ingenier√≠a del Software. Desde **la codificaci√≥n y documentaci√≥n de programas en lenguajes espec√≠ficos** hasta **el arte de traducir deseos humanos en instrucciones comprensibles para las computadoras**. Es un proceso creativo que implica **_limpiar, codificar, trazar y proteger el c√≥digo fuente_**. En esta materia, se destaca que **la programaci√≥n es tanto una disciplina como un arte** para crear software, donde un programador requiere habilidades esenciales para garantizar **la calidad del producto final, medida en t√©rminos de escalabilidad, reutilizaci√≥n y facilidad de mantenimiento.**

![image](https://github.com/AlexUnju/apuntes_fpoo/assets/142057928/64215b0e-66ed-4453-b5a0-9dbb16c04880)

### **üìï CONCEPTOS DERIVADOS DE LA PROGRAMACI√ìN**

**_Un programa de software es un conjunto de sentencias o instrucciones (algoritmos) escritos en
un lenguaje de programaci√≥n._**  <br>

Los programas forman parte de un conjunto m√°s grande
denominado **producto software**, el cual incluye los programas, **la documentaci√≥n de los
programas, la documentaci√≥n de an√°lisis y dise√±o de los programas, el manual de usuario, etc.**

En el desarrollo de un videojuego, el producto software incluye el c√≥digo fuente, el ejecutable, los instaladores, el manual, el documento de dise√±o (GDD), listas de assets y sonidos, concept art y la historia del juego.

En t√©rminos generales, un lenguaje de programaci√≥n es una herramienta que permite desarrollar programas para computadoras. Est√° compuesto por s√≠mbolos y reglas de sintaxis y sem√°ntica que definen su estructura y significado. El programador debe entender estas caracter√≠sticas para escribir algoritmos. Su funci√≥n principal es proporcionar un entorno para que los programadores creen programas que faciliten la comunicaci√≥n entre el usuario y la m√°quina.

Son muchos los tipos de lenguaje con los que un programador puede trabajar, pero nosotros
nos centraremos en dos: **Los lenguajes de bajo nivel y los lenguajes de alto nivel**.
#### ‚¨áÔ∏è Lenguaje de bajo nivel

El **lenguaje de bajo nivel** presenta ventajas como su sencillez, instrucciones directas y alta velocidad de ejecuci√≥n. Sin embargo, est√° estrechamente ligado al hardware, lo que puede dificultar la estructuraci√≥n de ciertos programas. Adem√°s, se requiere atenci√≥n especial para evitar errores que puedan aumentar la carga de trabajo y revisi√≥n del c√≥digo.
#### ‚¨ÜÔ∏è Lenguaje de alto nivel
Cuando hablamos de **lenguajes de alto nivel**, nos referimos a aquellos que se centran en las capacidades cognitivas humanas en lugar de en las capacidades de las m√°quinas. Estos lenguajes permiten a los programadores resolver problemas de manera sencilla y r√°pida, ofreciendo m√°xima flexibilidad y abstracci√≥n. Aunque generan un c√≥digo m√°s comprensible y v√°lido para diversas plataformas, pueden ralentizar el procesamiento ya que la computadora necesita m√°s tiempo para traducir las instrucciones. Adem√°s, algunos est√°n limitados a ciertas plataformas. En general, para los productos de software que se desarrollar√°n, los algoritmos se escribir√°n en un lenguaje de alto nivel.

##  VIDEO YOUTUBE PROGRAMACI√ìN <img src="https://i.ibb.co/0Y8QBHD/yt.png" alt="yt" border="0" height="20"> <br>
[![Texto alternativo](https://img.youtube.com/vi/IUTNblDwOfE/maxresdefault.jpg)](https://www.youtube.com/watch?v=IUTNblDwOfE)
 
### üìë FASES EN RESOLUCION DE PROBLEMAS MEDIANTE ALGORITMOS

El proceso de resoluci√≥n de problemas con una computadora implica escribir y ejecutar un programa. Aunque es un proceso creativo, sigue una serie de fases comunes que deben seguir la mayor√≠a de los programadores.

### üìñ FASES EN LA RESOLUCI√ìN DE PROBLEMAS CON COMPUTADORA
Las fases de resoluci√≥n de un problema con computadora son:
1 - An√°lisis del problema.
2 - Dise√±o del algoritmo.
3 - Codificaci√≥n.
4 - Compilaci√≥n y ejecuci√≥n.
5 - Verificaci√≥n.
6 - Depuraci√≥n.
7 - Mantenimiento.
8 - Documentaci√≥n.

  **Las caracter√≠sticas principales de la resoluci√≥n de problemas son:**

1. **An√°lisis:** Se estudia el problema considerando los requisitos especificados por el cliente o la persona encargada del programa.
2. **Dise√±o:** Se elabora una soluci√≥n que conduzca a un algoritmo para resolver el problema.
3. **Codificaci√≥n (Implementaci√≥n):** La soluci√≥n se traduce a la sintaxis de un lenguaje de alto nivel (como Java, C#, Processing, etc.) para crear archivos de c√≥digo fuente, que luego se traducen al lenguaje de la computadora.
4. **Ejecuci√≥n, Verificaci√≥n y Depuraci√≥n:** El programa se ejecuta, se verifica rigurosamente y se corrigen los errores ("bugs") que puedan surgir.
6. **Mantenimiento:** El programa se actualiza y modifica seg√∫n las necesidades de los usuarios.
7. **Documentaci√≥n:** Se documentan las diferentes fases del ciclo de vida del software, incluyendo an√°lisis, dise√±o, codificaci√≥n, as√≠ como manuales de usuario y de referencia, y normas para el mantenimiento.
Las dos primeras fases llevan al dise√±o detallado en forma de algoritmo. Durante la tercera fase (codificaci√≥n), se implementa este algoritmo en c√≥digo. La compilaci√≥n y ejecuci√≥n traducen y ejecutan el programa. En las fases de verificaci√≥n y depuraci√≥n, se buscan y corrigen errores. Es fundamental invertir tiempo en an√°lisis y dise√±o para reducir la necesidad de depuraci√≥n. Por √∫ltimo, se documenta el programa.

### ‚úçÔ∏è ALGORITMO Y METODOLOG√çA DE LA PROGRAMACI√ìN

Un algoritmo es un m√©todo para resolver un problema mediante una serie de pasos precisos,
definidos y finitos. Estas √∫ltimas tres palabras, son adem√°s las caracter√≠sticas de un algoritmo:
- **Preciso:** Indica el orden de realizaci√≥n de cada paso.
- **Definido:** Si se sigue dos veces, obtiene el mismo resultado cada vez.
- **Finito:** Tiene fin, un determinado n√∫mero de pasos.Debe producir un resultado en un tiempo finito.

Los m√©todos que utilizan algoritmos se llaman m√©todos algor√≠tmicos, mientras que los m√©todos que implican juicio se denominan m√©todos heur√≠sticos.
El eje central de esta metodolog√≠a es el concepto de algoritmo.
![image](https://github.com/AlexUnju/apuntes_fpoo/assets/142057928/7d08362e-a0b7-4243-8c11-8627cdece737)


Se consideran todos los elementos de un problema representado como un sistema inform√°tico:

1. Los datos de entrada (la situaci√≥n problem√°tica) y los datos de salida (la soluci√≥n) son esenciales para dise√±ar un algoritmo.

2. El dise√±o de un algoritmo implica una secuencia ordenada de pasos sin ambig√ºedades que conducen al desarrollo del proceso o estrategia. Esto incluye tanto la fase de an√°lisis del problema como la fase de dise√±o del algoritmo, donde se crea un modelo del programa que a√∫n no ha sido codificado.

3. A partir del dise√±o del algoritmo, se construye el programa en la fase de codificaci√≥n o implementaci√≥n.

4. El programa, junto con la configuraci√≥n del hardware y los documentos de desarrollo, constituyen el software del sistema inform√°tico. En este paso, el sistema puede ejecutarse, verificarse y depurarse, lo que corresponde a la fase de ejecuci√≥n de la resoluci√≥n de problemas mediante algoritmos.


|   |
|---|
| Entonces, la idea central de la Metodolog√≠a de la Programaci√≥n es que para llegar a la realizaci√≥n de un programa es necesario el dise√±o previo de un algoritmo, de modo que sin algoritmo no puede existir un programa. |

Los algoritmos son independientes del lenguaje de programaci√≥n y la computadora. Pueden expresarse en diferentes lenguajes y ejecutarse en diferentes m√°quinas manteniendo su esencia. En la ciencia de la computaci√≥n, los algoritmos son m√°s importantes que los lenguajes de programaci√≥n o las computadoras. Un lenguaje de programaci√≥n es solo un medio para expresar un algoritmo, y una computadora es simplemente un procesador para ejecutarlo.

### üß† AN√ÅLISIS DEL PROBLEMA

El an√°lisis del problema comprende dos etapas:

1. **Definici√≥n:** Se establece el prop√≥sito del algoritmo y se define claramente lo que se desea resolver, junto con los objetivos de su soluci√≥n.

2. **An√°lisis:** Se identifican las caracter√≠sticas del problema en t√©rminos de entradas y salidas, y se investigan los procesos necesarios para resolverlo. Se selecciona el proceso m√°s adecuado si hay varias opciones disponibles, o se desarrolla uno si no existen procesos previos.

![image](https://github.com/AlexUnju/apuntes_fpoo/assets/142057928/f334e5fc-337c-497c-9817-e79a4f1811c9)

**Ejemplo:** Se solicita desarrollar una calculadora que permita sumar dos n√∫meros

**Definici√≥n del Problema:** Desarrollar una calculadora que permita sumar dos n√∫meros

**An√°lisis:**
- Datos de Entrada: Dos n√∫meros, a los cuales denominaremos n√∫mero A y n√∫mero B
- Proceso:
-  - - ¬øQui√©n debe realizar el proceso?: Una calculadora
-  - - Cu√°l es el proceso que realiza la calculadora?
              
Donde lo que se ha aplicado es una ecuaci√≥n matem√°tica que la calculadora
puede realizar. La variable dependiente suma almacena el resultado de sumar
al n√∫mero A, el n√∫mero B.
- - - Datos de Salida: suma

### **üìè Consideraciones previas a la representaci√≥n de un algoritmo**

**Una variable** es un contenedor para almacenar informaci√≥n, compuesto por un identificador √∫nico y un tipo de datos que determina el rango de valores y operaciones aplicables. Los tipos de datos m√°s comunes incluyen **Entero, Real o Flotante, Car√°cter, Cadena de caracteres o string, y Fecha.** 

**La nomenclatura** del identificador sigue ciertas reglas comunes, como la unicidad y claridad del nombre, evitando el inicio con n√∫meros y utilizando may√∫sculas para separar palabras en nombres compuestos. Se sugiere evitar nombres excesivamente largos para facilitar la legibilidad. 

Adem√°s, se establecen convenciones para nombres espec√≠ficos, como **i, j, k para √≠ndices enteros**, **a, b, c para valores num√©ricos reales**, las variables llamadas **p y q se emplean para
apuntadores**; las variables llamadas **n y m son variables que contienen valores de tama√±os de matrices.**
Los nombres de variables se escriben en min√∫sculas para facilitar la lectura.

### üé® DISE√ëO DEL ALGORITMO
![image](https://github.com/AlexUnju/apuntes_fpoo/assets/142057928/7e83a87e-c4a6-466d-8c50-cc146e507da1)

#### CONCLUSI√ìN

El dise√±o de algoritmos es crucial en la ciencia de la computaci√≥n y se enfatiza en esta materia. Requiere creatividad y conocimiento t√©cnico. Los algoritmos pueden representarse de diversas formas. Se recomienda tomarse tiempo para analizar y dise√±ar antes de codificar, lo que evita problemas en la implementaci√≥n.

##  VIDEO FASES EN RESOLUCI√ìN DE UN ALGORITMO <img src="https://i.ibb.co/0Y8QBHD/yt.png" alt="yt" border="0" height="20"><br>

[![Texto alternativo](https://i.ytimg.com/vi/zXHAjyVmYEE/hqdefault.jpg?sqp=-oaymwE2CNACELwBSFXyq4qpAygIARUAAIhCGAFwAcABBvABAfgB_gmAAtAFigIMCAAQARhLIGUoOjAP&rs=AOn4CLCF5C2YNiaAYsIp4KSbog7pP8BWnA/maxresdefault.jpg)](https://www.youtube.com/watch?v=zXHAjyVmYEE)
#
# üîµ SEMANA 02
##
### üßÆ EXPRESI√ìN ARITM√âTICA
Las expresiones son combinaciones de constantes, variables, operadores y par√©ntesis. En algoritmos, las expresiones algebraicas se traducen a expresiones aritm√©ticas. Los operandos son las variables o constantes involucradas, mientras que los operadores realizan las operaciones entre ellos. El resultado de una expresi√≥n aritm√©tica es num√©rico, ya sea entero o real, y el punto se usa como separador decimal . Por ejemplo, suponga que ùëè = 4.5


### üìö OPERADORES ARITM√âTICOS

| Operador          | Descripci√≥n                      |
|-------------------|----------------------------------|
| +                 | Suma                             |
| -                 | Resta                            |
| *                 | Multiplicaci√≥n                   |
| /                 | Divisi√≥n                         |
| ** o ^            | Potenciaci√≥n                     |
| div               | Divisi√≥n entera                  |
| mod, %            | M√≥dulo (resto)                   |

Ejemplo:

| Operaci√≥n Matem√°tica | Expresi√≥n Aritm√©tica | Resultado |
|----------------------|----------------------|-----------|
| 5 + 3                | 5 + 3                | 8         |
| 10 - 4               | 10 - 4               | 6         |
| 2 x 6                | 2 * 6                | 12        |
| $\frac{15}{3}$       | 15 / 3               | 5         |
| $2^{3}$              | 2 ** 3               | 8         |
| 13 √∑ 5               | 13 div 5             | 2         |
| 13 mod 5             | 13 mod 5             | 3         |

### ‚ûñ‚ûñ‚ûï‚ûï OPERADORES DE INCREMENTO Y DECREMENTO

Los operadores de incremento (++), que aumentan el valor de su operando en una unidad, y de decremento (--), que disminuyen el valor de su operando en una unidad, son comunes en muchos lenguajes de programaci√≥n. Se pueden utilizar como prefijo (antes de la variable) o como sufijo (despu√©s de la variable), lo que afecta al valor resultante de la variable. Si se utiliza como prefijo, el operador cambia el valor de la variable y devuelve este nuevo valor; si se usa como sufijo, el resultado de la expresi√≥n es el valor de la variable, y luego se modifica esta variable.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/0c442d26-135d-4b28-8b56-3876693a43d0)

### üìè REGLAS DE PRIORIDAD

Las reglas de prioridad en expresiones aritm√©ticas determinan el orden de las operaciones. Estas reglas son:

1. Se eval√∫an primero las operaciones encerradas entre par√©ntesis, priorizando las m√°s internas.
2. Las operaciones aritm√©ticas siguen un orden de prioridad: primero los par√©ntesis, luego los operadores unitarios (++ y --), seguidos de multiplicaci√≥n, divisi√≥n y m√≥dulo, y finalmente suma y resta.
3. En lenguajes que admiten la operaci√≥n de exponenciaci√≥n, esta tiene la mayor prioridad.
4. Si hay varios operadores de igual prioridad, se sigue la asociatividad de izquierda a derecha.

Estas reglas garantizan un orden consistente en las operaciones.

| Operador          | Descripci√≥n                      |
|-------------------|----------------------------------|
| ()                | Parentesis                      |
| ++                | Incremento                      |
| --                | Decremento                      |
| *                 | Multiplicaci√≥n √≥ producto        |
| /                 | Divisi√≥n                         |
| %                 | M√≥dulo                           |
| +                 | Suma                             |
| -                 | Resta                            |

recordar el orden de prioridad son:
- ()
- ++, --
- *, /, %
- +, -

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/9b7b07c5-c938-45ee-bb23-62b33304c996)

### üìö BIFURCACI√ìN
Una bifurcaci√≥n es una interrupci√≥n en el flujo normal de ejecuci√≥n de un algoritmo, con lo cual
la linealidad de ejecuci√≥n se altera:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/a3f9ec2f-5f0a-4dda-a265-8f3480f31b12)

Las bifurcaciones pueden ser, seg√∫n el punto del algoritmo donde se aplique de dos tipos: hacia
adelante o hacia atr√°s 

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/cdd06818-2797-4d73-a26d-6715be928712)

### üìñ BIFURCACI√ìN CONDICIONAL Y LAS EXPRESIONES LOGICAS

Una bifurcaci√≥n condicional depende del cumplimiento de una condici√≥n espec√≠fica. En el esquema representado, la evaluaci√≥n de la condici√≥n se muestra dentro de un rombo. Si la condici√≥n se cumple, el flujo de ejecuci√≥n contin√∫a por la acci√≥n F2; de lo contrario, se ejecuta la acci√≥n F1. Despu√©s de ejecutar las acciones, el flujo de ejecuci√≥n contin√∫a normalmente, como indican las flechas que se unen en el c√≠rculo. La evaluaci√≥n de la condici√≥n devuelve un valor que indica si se cumple o no; por lo tanto, se necesita un tipo de datos capaz de almacenar estos valores, como VERDADERO o FALSO. 

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/2f974e7c-dc61-4269-89eb-7c6ae8c7267e)

### üìë EL TIPO DE DATOS BOOLEAN (O L√ìGICO)

El tipo de datos Boolean, tambi√©n conocido como l√≥gico, permite almacenar solo dos estados: verdadero o falso. Se define una variable de tipo Boolean de la siguiente manera: "variable: Boolean". Por ejemplo, una variable que indique si un jugador ha completado su misi√≥n en un juego se puede definir como "isMissionComplete: Boolean" o "haFinalizadoMision: Boolean". Este tipo de datos se utiliza com√∫nmente en ingl√©s para los identificadores debido a su brevedad y claridad. Para asignar el valor verdadero a una variable booleana, se utiliza "verdadero", mientras que para asignar falso se utiliza "falso". Por ejemplo, para asignar verdadero a la variable "isMissionComplete", se escribir√≠a "isMissionComplete ‚Üê verdadero"; y para asignar falso, se escribir√≠a "isMissionComplete ‚Üê falso".

### üßÆ LOS OPERADORES RELACIONALES

As√≠ como las expresiones aritm√©ticas utilizan operadores aritm√©ticos; las expresiones l√≥gicas utilizan operadores relaciones y l√≥gicos.

Los operadores relacionales permiten realizar comparaciones de valores de tipo num√©rico o
car√°cter. Los operadores de relaci√≥n sirven para expresar las condiciones en los algoritmos y el resultado de la operaci√≥n ser√° verdadero o falso.

| Operador | Significado       |
|----------|-------------------|
| <        | Menor que         |
| >        | Mayor que         |
| = o ==   | Igual que         |
| <=       | Menor o igual que |
| >=       | Mayor o igual que |
| <> o !=  | Distinto de       |

ejemplo:

| numA | numB | Expresi√≥n L√≥gica | Resultado           |
|------|------|------------------|---------------------|
| 5    | 3    | 5 < 3            | Falso        |
| 10   | 4    | 10 > 4           | Verdadero    |
| 3    | 3    | 3 == 3           | Verdadero     |
| 5    | 3    | 5 <= 3           | Falso      |
| 8    | 8    | 8 >= 8           | Verdadero    |
| 7    | 5    | 7 != 5           | Verdadero     |

### üß† LOS OPERADORES LOGICOS

Estos operadores generalmente se van a utilizan para realizar combinaciones de expresiones
l√≥gicas que usan operadores relacionales.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/b2909759-b2dd-4b25-a4f4-a3f302c86db2)

Estos operadores trabajan sobre un resultado booleano. Es decir, eval√∫an una variable booleana
o el resultado de una operaci√≥n l√≥gica basada en operadores relaciones y act√∫a en consecuencia
seg√∫n las denominadas tablas de verdad.

#### ! Operador L√≥gico NO

Al aplicar el operador no, lo que hace es negar (asignar el valor opuesto) de a. Por lo tanto, el
resultado de no a, ser√° falso.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/2a89462a-4cef-405e-9494-be942187b0ab)

#### && Operador L√≥gico Y (o conjunci√≥n)

El operador Y toma los valores que devuelven las expresiones l√≥gicas a y b; y eval√∫a el resultado
en conjunto. 
As√≠, si tanto a como b son verdaderas, el resultado en conjunto ser√° verdadero, caso contrario
devolver√° falso

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/9ca9620b-aa5b-43bf-bfb3-f3968d06564f)

#### || El Operador L√≥gico O (o disyunci√≥n)

El operador O toma los valores que devuelven las expresiones l√≥gicas a y b; y eval√∫a el resultado
en conjunto.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/f1dd6f48-aaa1-44b3-846b-82d947932092)
##

# üî¥ SEMANA 03
## Estructuras Iterativas

Las estructuras de control iterativas permiten repetir una o varias acciones un n√∫mero espec√≠fico de veces. Dentro de estas estructuras, el bloque de c√≥digo que se repite se conoce como bucle, y cada repetici√≥n se llama iteraci√≥n.

### üìö CONCEPTOS
- Estructura de control iterativa: es un tipo de estructura de control que permite repetir
una o varias acciones (instrucciones o sentencias) un determinado n√∫mero de veces.
- Bucle: se indica con este nombre a la secci√≥n de c√≥digo que se repite. Es decir, dentro
de una estructura de control iterativa hay un bucle, por el cual luego de ejecutar su
√∫ltima instrucci√≥n saltar√° a la primera de cumplirse cierta condici√≥n.
- Iteraci√≥n: Cada repetici√≥n de un bucle se conoce como iteraci√≥n.
- 
Al dise√±ar un bucle, es fundamental responder dos preguntas:
1. ¬øQu√© acciones se repiten?
2. ¬øCu√°ntas veces se deben repetir?

La primera pregunta determina si se necesita una estructura iterativa y qu√© acciones se repiten. La segunda pregunta implica asegurar que el n√∫mero de iteraciones sea finito para evitar bucles infinitos. Es crucial tener un mecanismo que garantice la finalizaci√≥n del bucle.

Por ejemplo, al calcular el factorial de 5 (5!), se realiza el producto de todos los n√∫meros enteros del 1 al 5. Aqu√≠, se ejecuta una operaci√≥n un n√∫mero finito de veces (5 veces) con una condici√≥n de parada clara.


### üìö ESTRUCTURA ITERATIVA MIENTRAS

La estructura iterativa mientras (en ingl√©s while) es aquella en la que el bucle se repite
mientras se cumple una determinada condici√≥n. Cuando se ejecuta la instrucci√≥n mientras,
la primera cosa que sucede es que se eval√∫a la condici√≥n (una expresi√≥n l√≥gica o booleana).
Si el resultado de la evaluaci√≥n devuelve falso, no se ejecutar√° el bucle continuando la ejecuci√≥n
del algoritmo fuera de la estructura mientras (se dice que salta hacia afuera del
fin_mientras). Si la expresi√≥n booleana retorna verdadero, entonces se ejecuta el bucle y
al llegar al final de este se proceder√° a evaluar nuevamente la expresi√≥n booleana.
Por lo tanto, las iteraciones se suceder√°n una tras otra mientras la expresi√≥n booleana
(condici√≥n) siga retornando el valor verdadero. A continuaci√≥n, se esquematiza la estructura de
control iterativa mientras

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/234aabc0-04f3-4df0-8751-0437cd17d846)

### üìë UNA VARIABLE CON OBJETIVO ESPEC√çFICO: EL CONTADOR

Una variable con un prop√≥sito espec√≠fico en estructuras de control iterativas es el contador. El contador se utiliza para rastrear el n√∫mero de iteraciones en un bucle. Su funci√≥n principal es mantener un registro del progreso del bucle, aumentando o disminuyendo su valor en cada iteraci√≥n. Esto permite controlar el n√∫mero de repeticiones y determinar cu√°ndo detener el bucle. El contador es esencial para estructuras como los bucles for y while, donde su valor se actualiza en cada ciclo hasta que se alcanza una condici√≥n de salida espec√≠fica.

### üìö ESTRUCTURA ITERATIVA HACER-MIENTRAS

El bucle mientras eval√∫a la expresi√≥n al comienzo del bucle de repetici√≥n; siempre se utilizan
para crear bucle pre-test. Los bucles pre-test se denominan tambi√©n bucles controlados por la
entrada. En numerosas ocasiones se necesita que el conjunto de sentencias que componen el
cuerpo del bucle se ejecute al menos una vez sea cual sea el valor de la expresi√≥n o condici√≥n
de evaluaci√≥n. 

Estos bucles se denominan bucles post-test o bucles controlados por la salida. Un caso t√≠pico es
el bucle hacer-mientras (do-while).

El bucle hacer-mientras es an√°logo al bucle mientras y el cuerpo del bucle se ejecuta
una y otra vez mientras la condici√≥n (expresi√≥n booleana) sea verdadera. Existe, sin embargo,
una gran diferencia y es que el cuerpo del bucle est√° encerrado entre las palabras reservadas
hacer y mientras, de modo que las sentencias de dicho cuerpo se ejecutan, al menos una
vez, antes de que se eval√∫e la expresi√≥n booleana. En otras palabras, el cuerpo del bucle siempre
se ejecuta, al menos una vez, incluso aunque la expresi√≥n booleana sea falsa.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/31d19624-1db7-4183-b9d7-fab7777497bf)

### üìö ESTRUCTURA ITERATIVA PARA

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/1e79b484-2901-4e93-b6ec-08b16eb26f78)

La estructura del bucle for comienza con un valor inicial (vi) de la variable de √≠ndice (v), y las acciones especificadas se ejecutan mientras el valor inicial sea menor o igual al valor final (vf).
La variable de √≠ndice (vi) se incrementa en uno por defecto, o por un valor mayor seg√∫n lo indicado por incr. Si este nuevo valor no excede el valor final (vf), las acciones se ejecutan nuevamente.
Por lo tanto, las acciones dentro del bucle se repiten para cada valor de la variable de √≠ndice desde el valor inicial hasta el valor final, con el incremento indicado en incr.
El incremento de la variable de √≠ndice suele ser 1 por defecto, pero puede ser diferente, positivo o negativo, seg√∫n lo especificado.
Normalmente, la variable de √≠ndice es de tipo entero y se suelen usar letras como i, j, k como nombres.
El formato de la estructura del bucle for var√≠a si se desea un incremento distinto a 1, ya sea positivo o negativo (decremento).

## ‚å®Ô∏è PROGRAMACI√ìN CON PROCESSING

### üì¶ VARIABLES

Las variables son elementos fundamentales en la computaci√≥n y en la programaci√≥n. Permiten almacenar valores durante la ejecuci√≥n de un programa y pueden modificarse seg√∫n sea necesario. Cada variable est√° asociada a un espacio f√≠sico en la memoria del ordenador, tiene un nombre √∫nico llamado identificador, y puede contener diferentes tipos de datos, como n√∫meros, texto, o valores l√≥gicos.
El identificador de la variable, elegido por el programador, debe ser descriptivo y no puede coincidir con palabras reservadas del lenguaje de programaci√≥n. Por otro lado, el valor almacenado en la variable debe ser definido previamente, es decir, se debe especificar qu√© tipo de dato contendr√° la variable, como n√∫meros enteros, decimales, texto, o valores l√≥gicos.

### üìö TIPOS DE DATOS EN PROCESSING

Processing ofrece varios tipos de datos para almacenar diferentes tipos de informaci√≥n. Estos se dividen en dos categor√≠as principales: primitivos y tipos de referencia. En este momento, nos centraremos en los primitivos.

1. **int**: Representa enteros de 32 bits con un rango desde -2.147.483.648 hasta 2.147.483.647.
2. **float**: Almacena n√∫meros con punto decimal, con un rango desde aproximadamente -3.4 √ó 10^38 hasta 3.4 √ó 10^38.
3. **char**: Permite almacenar caracteres individuales, como letras o s√≠mbolos, en el formato Unicode.
4. **boolean**: Solo puede almacenar dos valores: `TRUE` o `FALSE`, √∫til para controlar el flujo de los programas.
5. **color**: Permite almacenar colores codificados en n√∫meros hexadecimales.

Estos tipos de datos son fundamentales para definir variables y realizar operaciones en programas de Processing. Cada tipo tiene un rango de valores espec√≠fico y se utiliza seg√∫n las necesidades del programa.


### üìñ LAS VARIABLES PREDEFINIDAS (O DEL SISTEMA)

Processing proporciona varias variables predefinidas que pueden ser utilizadas directamente en los programas sin necesidad de declararlas. Estas variables son √∫tiles para obtener informaci√≥n sobre la ventana de trabajo, la interacci√≥n del usuario y otros aspectos del entorno de ejecuci√≥n. Algunas de las variables predefinidas m√°s importantes son:

1. `width`: Almacena el ancho de la ventana de trabajo.
2. `height`: Almacena el alto de la ventana de trabajo.
3. `frameRate`: Guarda la velocidad de ejecuci√≥n del programa.
4. `frameCount`: Contiene el n√∫mero de frames ejecutados desde el inicio del programa.
5. `displayHeight`: Almacena el alto de la pantalla completa.
6. `displayWidth`: Almacena el ancho de la pantalla completa.
7. `key`: Contiene el valor de la tecla recientemente oprimida.
8. `keyCode`: Detecta teclas especiales como flechas o teclas modificadoras.
9. `keyPressed`: Es verdadero si alguna tecla est√° siendo oprimida.
10. `mouseX`: La coordenada horizontal del mouse dentro de la ventana de trabajo.
11. `mouseY`: La coordenada vertical del mouse dentro de la ventana de trabajo.
12. `pmouseX`: La posici√≥n horizontal del mouse en el frame anterior.
13. `pmouseY`: La posici√≥n vertical del mouse en el frame anterior.
14. `mousePressed`: Indica si el bot√≥n del mouse est√° siendo oprimido.
15. `mouseButton`: Detecta qu√© bot√≥n del mouse fue seleccionado.
Estas variables simplifican el desarrollo de programas en Processing al proporcionar informaci√≥n relevante sobre la interacci√≥n del usuario y el entorno de ejecuci√≥n.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/9663e264-976d-4168-97e4-0ba2a9ec934f)


### üìö LAS ESTRUCTURAS DE CONTROL CONDICIONALES

En Processing, las estructuras de control condicionales son herramientas fundamentales para dirigir el flujo de ejecuci√≥n de un programa basado en condiciones espec√≠ficas. Estas estructuras incluyen:

1. **Estructuras Condicionales Simples:**
   - Permiten tomar decisiones basadas en una √∫nica comparaci√≥n.
   - Se utilizan para ejecutar un bloque de c√≥digo si una condici√≥n es verdadera.
   - La sintaxis b√°sica es:
     ```java
     if (condicion) {
         // Bloque de c√≥digo a ejecutar si la condici√≥n es verdadera
     }
     ```

2. **Estructuras Condicionales Dobles:**
   - Permiten elegir entre dos opciones basadas en el cumplimiento de una condici√≥n.
   - Se ejecuta un bloque de c√≥digo si la condici√≥n es verdadera y otro si es falsa.
   - La sintaxis b√°sica es:
     ```java
     if (condicion) {
         // Bloque de c√≥digo a ejecutar si la condici√≥n es verdadera
     } else {
         // Bloque de c√≥digo a ejecutar si la condici√≥n es falsa
     }
     ```

3. **Estructuras Condicionales M√∫ltiples Anidadas:**
   - Permiten evaluar una expresi√≥n contra m√∫ltiples resultados posibles.
   - Se utilizan m√∫ltiples `else if` despu√©s de un `if` para evaluar varias condiciones.
   - La estructura es:
     ```java
     if (condicion1) {
         // Bloque de c√≥digo a ejecutar si la condici√≥n1 es verdadera
     } else if (condicion2) {
         // Bloque de c√≥digo a ejecutar si la condicion2 es verdadera
     } else {
         // Bloque de c√≥digo a ejecutar si ninguna de las condiciones anteriores es verdadera
     }
     ```

Adem√°s, en Processing se utilizan operadores l√≥gicos como `&&` (AND) y `||` (OR) para realizar evaluaciones l√≥gicas combinadas.

### || && ! LOS OPERADORES L√ìGICOS

Los operadores l√≥gicos permiten hacer una evaluaci√≥n unificada, dado un conjunto de
expresiones l√≥gicas. Los operadores l√≥gicos que ofrece Processing son:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/663e1579-896f-422e-9055-ac9864294e3a)

- El &&: La conjunci√≥n es un operador que opera sobre dos valores de verdad.
T√≠picamente los valores de verdad de dos condiciones, devolviendo el valor de verdad
verdadero cuando ambas proposiciones son verdaderas, y falso en cualquier otro caso.
Es decir que es verdadera cuando ambas son verdaderas. La tabla de verdad de la
conjunci√≥n es la siguiente:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/bbfdcb3d-4eb9-4fbf-a830-31764724ddcb)

- El ||: La disyunci√≥n es un operador que funciona sobre dos valores de verdad,
t√≠picamente los valores de verdad de dos condiciones, devolviendo el valor de verdadero
cuando una de las proposiciones es verdadera, o cuando ambas lo son, y falso cuando
ambas son falsas.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/3385b998-d52b-470e-889b-049526b5a881)

### üìñ FUNCI√ìN RANDOM

La funci√≥n random() se refiere al proceso de aleatoriedad. Este t√©rmino se asocia a todo proceso
cuyo resultado no es previsible m√°s que por azar. El resultado de todo suceso aleatorio no puede
determinarse en ning√∫n caso antes de que este se produzca. En computaci√≥n, la funci√≥n
random() es capaz de generar un n√∫mero flotante aleatorio dado un rango de valores
proporcionado. 

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/9ca3a43a-d808-4c5f-98ec-4f71cbec2279)

### üîÅ ESTRUCTURA DE CONTROL ITERATIVAS

En cuanto a las estructuras de control iterativas, existen dos principales en Processing:

1. **La Instrucci√≥n `while`:**
   - Permite repetir un bloque de c√≥digo mientras se cumpla una condici√≥n.
   - La estructura b√°sica es:
     ```java
     while (condicion) {
         // Bloque de c√≥digo a repetir mientras la condici√≥n sea verdadera
     }
     ```

2. **La Instrucci√≥n `for`:**
   - Se utiliza cuando se conoce de antemano el n√∫mero de veces que se debe repetir un bloque de c√≥digo.
   - La estructura b√°sica es:
     ```java
     for (inicializaci√≥n; condici√≥n; actualizaci√≥n) {
         // Bloque de c√≥digo a ejecutar mientras se cumpla la condici√≥n
     }
     ```

Estas estructuras de control son esenciales para dirigir el flujo de ejecuci√≥n de un programa y tomar decisiones basadas en condiciones espec√≠ficas. Tambi√©n facilitan la repetici√≥n de bloques de c√≥digo, lo que permite una programaci√≥n m√°s eficiente y estructurada.

##PROGRAMACI√ìN CREATIVA

El avance de las tecnolog√≠as digitales ha impactado en el desarrollo personal y profesional, incluyendo a los artistas y dise√±adores. La integraci√≥n de la programaci√≥n y el arte es esencial en el dise√±o de videojuegos, y aprender programaci√≥n usando herramientas creadas por dise√±adores puede ser beneficioso.

### üß† La programaci√≥n creativa:
La programaci√≥n creativa es un movimiento que establece que los lenguajes de programaci√≥n
se conciben como medios creativos, a la altura de la m√∫sica, la danza o la pintura.
En este enfoque los lenguajes de programaci√≥n son considerados un nuevo est√°ndar
internacional para crear aplicaciones en cualquier parte del mundo y para cualquier parte del
mundo. Esto se torna mucho m√°s visible en el mundo del desarrollo de videojuegos, donde se
mezcla el arte y la programaci√≥n para crear expresiones de sensaciones. Los videojuegos son un
medio para transmitir sensaciones por medio de la inmersi√≥n (la experiencia cierta de poder
expresarse dentro de un mundo ficticio).

### ‚úçÔ∏è El c√≥digo creativo:
El centro de la programaci√≥n creativa es el c√≥digo creativo, donde el c√≥digo de la computadora se trata como un medio creativo natural. La forma en que se resuelve un problema es tan importante como la soluci√≥n en s√≠ misma. La programaci√≥n creativa utiliza bases de matem√°ticas, f√≠sica, computaci√≥n y teor√≠a art√≠stica para encontrar soluciones interesantes y novedosas.

El centro de la programaci√≥n creativa es el c√≥digo creativo, el cual se define como

**`ùëê√≥ùëëùëñùëîùëú ùëêùëüùëíùëéùë°ùëñùë£ùëú = ùëéùëüùë°ùëí + ùëêùëñùëíùëõùëêùëña`**

### Combatir prejuicios:
La programaci√≥n creativa busca combatir prejuicios sobre las ciencias de la computaci√≥n, promoviendo el "aprendizaje haciendo" a trav√©s de la construcci√≥n de bocetos de c√≥digo creativo. Se desaf√≠a la idea de  que sostienen que las mismas son dif√≠ciles, aburridas y oscuras o solo para ciertos tipos de personas, y se fomenta la exploraci√≥n creativa y el descubrimiento en el proceso de aprendizaje.

### üìö QUE ES PROCESSING

**Es un entorno de programaci√≥n open source (c√≥digo abierto) basado en el lenguaje de programaci√≥n Java para gente creativa. La premisa es que no es necesario que estas personas**

### üí°ENFOQUE PEDAG√ìGICO CON PROCESSING

Processing fue creado para ense√±ar los fundamentos
de la programaci√≥n computacional dentro de un
contexto visual para servir como software de bocetos
y ser usado como herramienta de producci√≥n.

El modelo de bocetos de la herramienta es totalmente
compatible con el modelo de conceptos que se utiliza
para dise√±ar videojuegos; por lo cual resulta apropiado
para la ense√±anza de los principios b√°sicos de la
programaci√≥n. Y es que resulta que el documento de
conceptos es la primera referencia del juego para el
equipo de desarrollo. En √©l detallamos la visi√≥n general del juego y nos permitir√° tener una idea
clara de los objetivos que queremos alcanzar.
## 

# üü° SEMANA 04
## üß† CONCEPTO PARADIGMA
El estadounidense **Thomas Kuhn**, los define como:

**`La serie de pr√°cticas que trazan los lineamientos de una disciplina cient√≠fica a lo largo de un cierto lapso temporal. El √©xito de un paradigma es consecuencia de su efectividad para resolver alg√∫n problema.`**

Las pr√°cticas hacen referencia a:

- **Las leyes establecidas y los supuestos te√≥ricos.** Por ejemplo, las leyes de movimiento
de Newton forman parte del paradigma newtoniano y las ecuaciones de Maxwell
forman parte del paradigma que constituye la teor√≠a electromagn√©tica cl√°sica.

- **El instrumental y las t√©cnicas instrumentales** necesarias para hacer que las leyes del
paradigma se refieran al mundo real. La aplicaci√≥n en astronom√≠a del paradigma
newtoniano requiere el uso de diversos telescopios, junto con t√©cnicas para su
utilizaci√≥n y diversas t√©cnicas para corregir los datos recopilados.

- **Los principios generales propios** del paradigma que gu√≠an el trabajo dentro del
paradigma. Por ejemplo, para construir una un puente, se deben seguir ciertos pasos,
medidas y m√©todos preestablecidos para garantizar que el trabajo se realice de manera
correcta.

Respecto del **lapso temporal**, se hace referencia a que los paradigmas son el resultado de un proceso social en el que un grupo de individuos desarrolla nuevas ideas y establece principios y pr√°cticas en torno a esas ideas. Se destaca que un paradigma puede ser efectivo para explicar ciertos aspectos del mundo, pero puede ser inaplicable u obsoleto para otros fen√≥menos, lo que sugiere la posible existencia de otros paradigmas m√°s adecuados. Este fen√≥meno se interpreta como una consecuencia natural del proceso de evoluci√≥n o maduraci√≥n del concepto. Se ilustra este punto con un ejemplo en la programaci√≥n de videojuegos, donde se plantea que pueden existir m√∫ltiples paradigmas aplicables y que algunos pueden ser m√°s adecuados que otros para diferentes tipos de problemas.

En las ciencias sociales, un paradigma se utiliza
para explicar la forma en que se entiende el
mundo. Se emplea para mencionar a todas
aquellas experiencias, creencias, vivencias y
valores que repercuten y condicionan el modo en
que una persona ve la realidad y act√∫a en funci√≥n
de ello.

De esta manera para brindar una definici√≥n formal, se considera paradigma a:
- Los marcos de referencia que imponen reglas sobre c√≥mo se deben hacer las cosas,
indican qu√© es v√°lido dentro del paradigma y qu√© est√° fuera de sus l√≠mites. Un paradigma
distinto implica nuevas reglas, elementos, l√≠mites y maneras de pensar, o sea implica un
cambio.
- Patrones de pensamiento para la resoluci√≥n de problemas. Un modelo o esquema
fundamental que organiza nuestras opiniones con respecto a alg√∫n tema en particular.
Los paradigmas establecen l√≠mites adoptados por los miembros de una comunidad
cient√≠fica para resolver problemas sustentados por los principios, leyes, supuestos
te√≥ricos y t√©cnicas que la conforman.

### üóÉÔ∏è ELEMENTOS DE LOS PARADIGMAS
Sin entrar en detalles, los paradigmas se sustentan en teor√≠as, creencias, valores, leyes, t√©cnicas
e hip√≥tesis. Debido a esta formalidad, este √∫ltimo esquema intenta diferenciar conceptos que
normalmente son confundidos con paradigmas

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/84463e50-2918-4da4-9384-4b840e39168e)



### üìö PARADIGMAS DE PROGRAMACI√ìN
## üìöüìö Caracteristicas de PARADIGMAS: 

`**1ra Caracter√≠stica de paradigma:** Los objetos son contenedores de la
informaci√≥n y la funcionalidad que se pueden programar.`

`**2da Caracter√≠stica del Paradigma:** Los objetos interact√∫an, colaborando
para que el programa cumpla su objetivo.`

 `**3ra Caracter√≠stica del Paradigma:** Los
objetos se crean a partir¬†de¬†clases.`


Existen diferentes concepciones para los paradigmas de programaci√≥n:

- **Un proceso de dise√±o que va m√°s all√° de una
gram√°tica, reglas sem√°nticas y algoritmos.** Es un
conjunto de m√©todos sistem√°ticos aplicables en
todos los niveles del dise√±o de programas.
Representan un enfoque particular o filosof√≠a
para la construcci√≥n del software.

- **Son propuestas tecnol√≥gicas adoptadas por la
comunidad de desarrolladores que se enfocan a
resolver uno o varios problemas definidos y
delimitados.**

- **Es un modelo b√°sico de dise√±o y desarrollo de programas, que permite producir
programas con unas directrices espec√≠ficas**, tales como: estructura modular, fuerte
cohesi√≥n, alta rentabilidad, etc.

- **Es una colecci√≥n de modelos conceptuales que en conjunto modelan el proceso de
dise√±o y determinan la estructura de un programa.** Esa estructura conceptual de
modelos est√° pensada de forma que los modelos determinan la forma correcta de los
programas y controlan el modo en que el desarrollador piensa y formula soluciones, que
luego son implementadas en un lenguaje de programaci√≥n.

- **Provee y determina la visi√≥n y m√©todos de un programador en la construcci√≥n de un
programa o subprograma.** Diferentes paradigmas resultan en diferentes estilos de
programaci√≥n y en diferentes formas de pensar la soluci√≥n de problemas (con la
soluci√≥n de m√∫ltiples ‚Äúproblemas‚Äù se construye una aplicaci√≥n o producto de software).

Existen tres cuestiones para tener en cuenta respecto de los paradigmas de programaci√≥n:

1. Ning√∫n paradigma es mejor que otro, sino que cada uno tiene ventajas y desventajas.
Tambi√©n hay situaciones donde un paradigma resulta m√°s apropiado que otro.
2. Para que las caracter√≠sticas esenciales del paradigma sean efectivamente aplicadas, las
caracter√≠sticas del lenguaje de programaci√≥n utilizado para implementar la aplicaci√≥n
deben reflejar adecuadamente los modelos conceptuales de ese paradigma. Cuando un
lenguaje refleja bien un paradigma particular, se dice que soporta el paradigma, y en la
pr√°ctica un lenguaje que soporta correctamente un paradigma, es dif√≠cil distinguirlo del
propio paradigma.
3. Los lenguajes de programaci√≥n est√°n basados en uno o m√°s paradigmas, por ejemplo:
Processing est√° basado en el paradigma orientado a objetos. El lenguaje de
programaci√≥n Scheme, en cambio, soporta solo programaci√≥n funcional. Otros
lenguajes, como C++ y Python soportan m√∫ltiples paradigmas.

### üòÉ EL PARADIGMA ORIENTADO A OBJETOS DE MANERA RESUMIDA

El paradigma de programaci√≥n orientada a objetos, que se fundamenta en la idea de representar problemas y soluciones de manera similar al procesamiento de informaci√≥n del cerebro humano. En este paradigma, los problemas y soluciones se representan como entidades llamadas objetos, que poseen atributos almacenados en variables especiales y operaciones que act√∫an sobre esos atributos mediante algoritmos espec√≠ficos.

Los objetos se comunican entre s√≠ a trav√©s de mensajes, estableciendo relaciones seg√∫n un conjunto de reglas y normas definidas en el protocolo de mensajes. Este paradigma se sustenta en cuatro pilares:** abstracci√≥n, encapsulaci√≥n, herencia y polimorfismo.** Estos pilares estructuran la creaci√≥n, uso y destrucci√≥n de objetos mediante clases, y establecen un contrato entre clases para la implementaci√≥n de operaciones. Adem√°s, definen formalmente qu√© es un objeto, c√≥mo se modelan y c√≥mo se optimiza la reusabilidad y mantenimiento del c√≥digo.

### ‚úçÔ∏è EL MODELADO Y LA ABSTRACCI√ìN EN EL PARADIGMA ORIENTADO A OBJETOS

El modelado es una t√©cnica que consiste en
representar informaci√≥n mediante un modelo. Un
modelo es una abstracci√≥n de una realidad. El
t√©rmino abstracci√≥n hace referencia al proceso de
centrarse √∫nicamente en los detalles relevantes del
fen√≥meno estudiado o que es objeto de
observaci√≥n.
La abstracci√≥n es tambi√©n, una de las propiedades del paradigma orientado a objetos; esto
significa que el paradigma orientado a objetos buscar√° a trav√©s de esta propiedad:

- Abstraer un problema (determinar los aspectos relevantes del problema resolver) para
luego realizar una,
- abstracci√≥n de la soluci√≥n de ese problema (determinar los aspectos relevantes de la
soluci√≥n que se propone como soluci√≥n al problema) y finalmente
- construir una abstracci√≥n del sistema inform√°tico creado. Esto significa que los aspectos
relevantes del producto sean programados, probados y documentados en la forma de
clases y sus interrelaciones, para que otros desarrolladores puedan interpretarlos.

### üß† CARACTERISTICAS DEL MODELADO
El modelado ofrece 4 caracter√≠sticas esenciales:

1) Una visualizaci√≥n de un sistema: tanto del
problema a solucionar como de la soluci√≥n. En
ambos casos estamos refiri√©ndonos a una
aproximaci√≥n (en el primer caso una
aproximaci√≥n de los objetos de nuestro juego y
como ellos interact√∫an, mientras que del
segundo caso un esquema y documentaci√≥n del software del videojuego)
2) Una especificaci√≥n de su comportamiento: nos permite indicar detalladamente como
act√∫a el mismo ante diferentes situaciones.
3) Una plantilla que gu√≠e a los desarrolladores durante su construcci√≥n: es decir son los
‚Äúplanos‚Äù que el arquitecto del software sigue para construir el producto.
4) Documentar decisiones de dise√±o: siempre las decisiones de dise√±o deben estar bien
documentadas y justificadas. En algunas metodolog√≠as la documentaci√≥n se dejaba al
√∫ltimo; o como sucede de forma muy habitual est√° la tentaci√≥n de no documentar por
el tiempo que incurre. Los modelos permiten minimizar el tiempo de documentaci√≥n. 

### üß†üß† LOS semana  DE LA ABSTRACCI√ìN DE OBJETOS

El modelo orientado a objetos permite construir una representaci√≥n para analizar, describir,
explicar simular o predecir un fen√≥meno y se sustenta alrededor de las siguientes definiciones:
- **Clase:** modelo, molde, plano o maqueta a partir del cual se pueden generar objetos. Las
clases son entidades utilizadas para analizar el problema y dise√±ar la soluci√≥n. Toda clase
posee 3 elementos importantes: el nombre de la clase, los atributos y las operaciones. Mediante las clases se pueden determinar los actores (clases) que participan en el
problema estudiado (o en la soluci√≥n) as√≠ como las caracter√≠sticas y acciones que estas
entidades poseen y que contribuyen de alguna manera para que se cumplan los
objetivos abordados por la soluci√≥n planteada (los requisitos). Las clases son
programadas en un lenguaje de programaci√≥n orientado a objetos.

- **Objeto**: Los programas se ejecutan en memoria, adoptando el nombre de procesos. En
el caso de los programas orientados a objetos estos procesos se denominan objetos que
adquieren los atributos y operaciones de la clase a partir de la cual se ha creado, de esta
manera en memoria pueden existir muchos objetos generados a partir de la misma clase
pero cada una con su propia identidad que la separa de las dem√°s (esto puede
asemejarse al hecho de que a partir de un mismo plano se pueden construir varias
viviendas, todas iguales por las especificaciones del plano pero en definitiva cada una
es una construcci√≥n individual)
- **Relaciones:** Indica la forma en que los objetos colaboran entre ellos para realizar alguna
tarea espec√≠fica. Esto genera un nuevo concepto que es el mensaje: es el mecanismo
por el cual un objeto en memoria solicita a otro que ejecute una operaci√≥n. Entonces
las relaciones indican la forma en que los objetos env√≠an mensajes a otros objetos.
- **Interfaz:** Las operaciones de un objeto que pueden ser solicitadas por otro objeto se
denominan servicios. Para que los servicios de un objeto puedan ser invocados por otro
objeto; el objeto que desea ponerlos a disposici√≥n de los otros objetos debe definir una
interfaz. La interfaz es simplemente un mecanismo por el cual se determina si una
operaci√≥n se halla disponible para ser invocada por otro objeto (las operaciones dentro
del objeto siempre son servicios para las otras operaciones del mismo objeto, esto es,
las operaciones de un objeto siempre pueden ser invocadas por las otras operaciones
del mismo objeto). El concepto de interfaz tambi√©n se aplica a los atributos, esto es; si
no se especifica una interfaz para un atributo, el mismo no podr√° estar disponible para
otros objetos.

## LA ABSTRACCI√ìN DE LAS CLASES 

**Introducci√≥n a la abstracci√≥n en el paradigma orientado a objetos**

La abstracci√≥n, piedra angular del paradigma orientado a objetos, es un proceso crucial para identificar las caracter√≠sticas esenciales y los comportamientos comunes de una parte de la realidad. Este proceso permite definir las entidades que representan el sistema estudiado y es fundamental en el an√°lisis y dise√±o orientado a objetos, ya que facilita la determinaci√≥n de las clases que modelan el problema a resolver.

### **La importancia de la clase como entidad fundamental**

La clase, entendida como una entidad que describe un conjunto de objetos con estructura y comportamiento similares, es un concepto central en la programaci√≥n orientada a objetos. Se asemeja a un "molde" del cual se pueden crear m√∫ltiples objetos del sistema inform√°tico. Esta analog√≠a con los moldes para hornear ilustra c√≥mo las clases permiten obtener objetos con caracter√≠sticas espec√≠ficas.

### **Principio de abstracci√≥n: distinci√≥n, focalizaci√≥n y clasificaci√≥n**

El principio de abstracci√≥n en el paradigma orientado a objetos se basa en tres premisas fundamentales: distinguir diferentes objetos, focalizarse en las caracter√≠sticas y operaciones esenciales de esos objetos, y clasificar los objetos en base a sus caracter√≠sticas y operaciones comunes en clases. Este principio refleja un proceso natural que todos aplicamos en nuestra vida cotidiana al diferenciar entre diversos tipos de objetos y enfocarnos en sus propiedades esenciales.

**Aplicaci√≥n del principio de abstracci√≥n en situaciones cotidianas**

Desde la infancia, aprendemos a clasificar objetos y a distinguir entre ellos. Ya sea diferenciando entre seres vivos y objetos inanimados o identificando herramientas y juguetes, ejercemos la capacidad de abstracci√≥n de manera intuitiva. Adem√°s, en nuestras actividades diarias, como practicar un deporte, aplicamos la abstracci√≥n al centrarnos en las propiedades esenciales comunes de los objetos involucrados, como compa√±eros de equipo, pelotas y objetivos del juego.

**Importancia de la abstracci√≥n en el desarrollo de videojuegos**

La abstracci√≥n juega un papel crucial en el desarrollo de videojuegos. Cada elemento de un juego, desde personajes hasta objetos y entornos, se representa mediante clases que definen su estructura y comportamiento. Estas clases son la base para la creaci√≥n de los GameObjects, que son los objetos individuales en el juego.

**Ejemplo pr√°ctico: identificaci√≥n de clases en una pantalla de juego**

En una pantalla de juego, cada elemento visible est√° respaldado por clases que representan su funcionalidad y apariencia. Al identificar estas clases junto con sus atributos y operaciones, podemos entender c√≥mo se generan los GameObjects y c√≥mo interact√∫an en el juego.

### **Modelado de la abstracci√≥n: Introducci√≥n al Diagrama de Clases en UML**

El modelado de la abstracci√≥n de objetos se lleva a cabo mediante el uso de diagramas estandarizados, siendo el Diagrama de Clases de UML (Unified Modeling Language) uno de los m√°s prominentes. Este diagrama es fundamental para especificar la estructura de datos de un sistema de informaci√≥n en el √°mbito del modelado orientado a objetos.

### üë™ **Familias de Diagramas en UML**

UML ofrece dos grandes familias de diagramas: los diagramas de estructuras y los diagramas de comportamiento. Los primeros se centran en la arquitectura de datos del sistema, mientras que los segundos se enfocan en especificar su comportamiento.

### üóÉÔ∏è **Diagramas de Clase: Aspectos Generales**

El Diagrama de Clases es esencial en UML, ya que se utiliza principalmente para definir la estructura de datos de un sistema. Este diagrama constituye la base de cualquier soluci√≥n en el modelado orientado a objetos, ya que incluye el conjunto de clases que conforman la estructura b√°sica del sistema y distribuye los datos que maneja a trav√©s de sus atributos.

An√°logamente al cuerpo humano, donde las clases y sus atributos representan el esqueleto del sistema, el Diagrama de Clases tambi√©n permite definir los "m√∫sculos" que permiten la movilidad del sistema, es decir, las operaciones y relaciones entre clases que determinan su funcionamiento.

### üìñ **Representaci√≥n de Clases en UML**

En un Diagrama de Clases, una clase se representa como una caja que puede dividirse en una, dos o tres partes. La primera parte siempre indica el nombre de la clase. Si la clase se divide en tres secciones, la segunda parte corresponde a los atributos y la tercera a las operaciones. En caso de que la clase solo tenga dos secciones, la segunda puede referirse tanto a los atributos como a las operaciones.

**Ejemplo Pr√°ctico: Clase Avi√≥n en UML**

Para ilustrar este concepto, consideremos la clase Avi√≥n. En el diagrama, se representa expl√≠citamente las tres partes de la clase: nombre (Avi√≥n), atributos (modelo, cantidad de motores, velocidad y capacidad) y operaciones (acelerar y girar en una direcci√≥n). Este ejemplo muestra c√≥mo se modela una clase en UML y c√≥mo se pueden definir objetos a partir de ella.


![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/c28c85d4-6b14-4101-a3a3-c4c860ec2e6d)


**En conclusi√≥n, el Diagrama de Clases en UML es una herramienta fundamental para el modelado de la abstracci√≥n en la programaci√≥n orientada a objetos, permitiendo representar la estructura de datos de un sistema y definir sus relaciones y comportamientos de manera clara y concisa.**

### üìèüìè ** Nomenclatura para la Definici√≥n de Nombres de Clases**

1. Los nombres de las clases deben ser sustantivos en singular.
2. La primera letra del nombre debe comenzar en may√∫scula, seguida de letras min√∫sculas.
3. No se permiten espacios en los nombres. Durante la fase de an√°lisis en UML, se puede usar guion bajo (_) para separar palabras en el nombre de la clase. Sin embargo, durante la fase de dise√±o, es una pr√°ctica com√∫n que la primera letra de cada palabra subsecuente est√© en may√∫scula. Esta √∫ltima recomendaci√≥n se aplicar√° en todos los diagramas de clases realizados en la asignatura.

**Caracter√≠sticas Avanzadas de una Clase: Visibilidad**

Adem√°s de los elementos b√°sicos como el nombre, atributos y operaciones, una clase tambi√©n cuenta con propiedades avanzadas que permiten especificar aspectos m√°s detallados de la clase modelada. Entre estas propiedades, la visibilidad es fundamental, ya que determina el acceso que otras clases tendr√°n a los atributos y operaciones de la clase.

**Definici√≥n de Visibilidad**

La visibilidad establece la disponibilidad que ofrece una clase a otras clases en cuanto al uso o acceso de sus atributos y operaciones. Se puede especificar si un atributo u operaci√≥n est√° totalmente disponible para otras clases, o si est√° restringido y no disponible para ninguna otra clase. Adem√°s, existen niveles intermedios de visibilidad que pueden variar seg√∫n el lenguaje de programaci√≥n utilizado.

### üéöÔ∏è **Niveles de Visibilidad en UML**

En UML, se definen cuatro niveles de visibilidad:

1. **P√∫blico (+)**: La visibilidad se extiende a otras clases, lo que significa que cualquier clase puede acceder a ese atributo u operaci√≥n.

2. **Protegido (#)**: La visibilidad se extiende √∫nicamente a las subclases de la clase original. Esto se profundizar√° m√°s adelante cuando se aborde el concepto de herencia.

3. **Privado (-)**: En este nivel, solo la clase original puede acceder a los atributos y operaciones privadas.

4. **Paquete (~)**: Introducido en UML 2.5 para reflejar pr√°cticas de algunos lenguajes de programaci√≥n. La visibilidad se extiende a las clases que comparten el mismo paquete en el que se ha definido la clase original. Fuera de este paquete, otras clases no pueden acceder al atributo u operaci√≥n a menos que sean subclases.


### üìí **Definici√≥n de Atributos en UML**

La definici√≥n de un atributo en UML implica considerar varios aspectos para una descripci√≥n completa y precisa. Un atributo representa una caracter√≠stica espec√≠fica de un objeto y es, en esencia, una variable que almacena un valor. Para una representaci√≥n adecuada en UML, es esencial comprender los tipos de datos predefinidos que ofrece UML y c√≥mo se aplican en la definici√≥n de atributos. A continuaci√≥n, se presentan los tipos de datos predefinidos en UML, junto con ejemplos de su uso:

1. **Boolean**: Indica un valor l√≥gico que puede ser verdadero o falso. Ejemplo: `isFinishedTime: boolean`

2. **Byte**: Representa un tipo num√©rico para enteros con un rango limitado, generalmente entre -128 y 127. Ejemplo: `cantidadVidas: byte`

3. **Short**: Indica un tipo num√©rico para enteros con un rango m√°s amplio que Byte. Ejemplo: `puntajeBonus: short`

4. **Integer**: Representa un tipo num√©rico para enteros con rangos muy grandes. Ejemplo: `puntajeAcumulado: integer`

5. **Long**: Indica un tipo num√©rico para enteros mucho m√°s grandes que Integer, t√≠picamente utilizado en c√°lculos cient√≠ficos. Ejemplo: `distanciaAsaturno: long`

6. **Float**: Representa un tipo num√©rico para n√∫meros reales, √∫til para aplicaciones de videojuegos que manipulan decimales. Ejemplo: `resultadoOperacion: float`

7. **Double**: Indica un tipo num√©rico para n√∫meros reales muy grandes, com√∫nmente utilizado en c√°lculos cient√≠ficos. Ejemplo: `derivada: double`

8. **Date**: Representa un tipo para valores que representan fechas. Ejemplo: `fecNac: date`

9. **String**: Indica un tipo que representa cadenas de caracteres, √∫tiles para almacenar texto. Ejemplo: `Nacionalidad: string`

10. **Char**: Representa un √∫nico car√°cter. Ejemplo: `teclaSeleccionada: char`

Al definir atributos en UML, es esencial considerar el tipo de dato adecuado para cada caracter√≠stica del objeto que se est√° modelando, garantizando as√≠ una representaci√≥n precisa y coherente del sistema.

### üìê **Nomenclatura para la Definici√≥n de Atributos**

La nomenclatura adoptada para la definici√≥n de atributos en esta materia sigue las convenciones del lenguaje de programaci√≥n Java. A continuaci√≥n, se describen las reglas que se aplicar√°n:

1. Los atributos deben iniciar con una letra min√∫scula.
2. No pueden comenzar con un n√∫mero.
3. El nombre del atributo debe reflejar claramente el significado de la caracter√≠stica que representa en la clase. Por ejemplo, para una clase `NaveEspacial` que tiene un atributo que indica la cantidad de vidas, un nombre v√°lido para el atributo ser√≠a `cantVidas`, mientras que nombres como `v` o `cv` ser√≠an inv√°lidos.
4. No se permiten espacios en los nombres de los atributos. En la fase de an√°lisis del Diagrama de Clases, se admite el uso de guion bajo (_), pero en la fase de dise√±o se seguir√° la convenci√≥n de que la primera letra de cada palabra subsiguiente est√© en may√∫scula.

## üìö ** Nomenclatura para Definici√≥n de Operaciones**

Las operaciones representan acciones que pueden ser realizadas por los objetos creados a partir de una clase. La nomenclatura para la definici√≥n de operaciones en esta materia sigue las convenciones del lenguaje Java:

1. Las operaciones deben ser verbos en infinitivo.
2. Se escriben en min√∫scula.
3. No se admiten espacios en los nombres de las operaciones. En la fase de an√°lisis del Diagrama de Clases, se admite el uso de guion bajo (_), pero en la fase de dise√±o se seguir√° la convenci√≥n de que la primera letra de cada palabra subsiguiente est√© en may√∫scula.

En un diagrama de clases, las operaciones se definen siguiendo la sintaxis:

\[visibilidad\] nombre ([lista de par√°metros])[:tipo de retorno]

Los corchetes indican que estos elementos son opcionales, por lo que solo el nombre de la operaci√≥n es requerido.

# ‚ö´ Semana 5

Las aplicaciones orientadas a objetos rara vez definen clases cuyos objetos trabajen de manera aislada. Un buen dise√±o utiliza objetos de diferentes clases que cooperan para alcanzar el objetivo central del dominio del negocio. Por eso, esta secci√≥n se centrar√° en c√≥mo los objetos colaboran entre ellos para realizar tareas espec√≠ficas y c√≥mo representarlo en un diagrama de clases, conocidas como relaciones entre clases. Se definir√°n los diferentes tipos de relaciones y se dar√°n ejemplos aclaratorios.

## ‚ÜïÔ∏è RELACIONES ENTRE CLASES
Las relaciones permiten establecer c√≥mo interact√∫an las clases. En UML se representan
mediante una l√≠nea. Existen diferentes tipos de relaciones:
- ‚úì Asociaci√≥n
- ‚úì Agregaci√≥n
- ‚úì Dependencia
- ‚úì Implementaci√≥n
- ‚úì Herencia

### La asociaci√≥n
Permite establecer una relaci√≥n conceptual entre dos clases. Especifica una conexi√≥n entre los
objetos de una clase y los objetos de otra clase. Describiremos las caracter√≠sticas de las
asociaciones mediante ejemplos.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/89d54900-9aac-4dfe-b927-5e2aba6ce473)

La asociaci√≥n establece una relaci√≥n conceptual entre dos clases, conectando objetos de una clase con objetos de otra. Se representa con una l√≠nea en los diagramas y es una relaci√≥n no jer√°rquica, conocida tambi√©n como **una relaci√≥n de igual a igual.** Esta relaci√≥n puede ser **direccional**, indicada con una flecha, mostrando hacia qu√© objeto se puede navegar. Es decir, ninguna de las dos tiene
un estatus superior respecto de la otra (como sucede y se ver√° en la herencia, las clases
abstractas y las interfaces).
El extremo con la flecha es el** objetivo u objeto** hacia el que se puede navegar. El extremo sin la
flecha se denomina **fuente**.

### Frase semantica de asociacion:
‚Äùtiene o conoce‚Äù 
un atributo cuyo tipo es de la otra clase; esto aplicado a nuestro ejemplo ser√≠a: un equipo tiene un solo estadio. El significado conceptual tambi√©n recibe
el nombre de frase sem√°ntica.

### multiplicidad

Lo que debe quedar claro es que son autoexcluyentes. Es decir, la multiplicidad de un atributo o es expresada en el atributo o es
expresada en la relaci√≥n. Gr√°ficamente, esto es

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/5f322c3a-00f5-4dee-a952-24c4e8e8c34f)

Puede observar que la relaci√≥n de asociaci√≥n brinda mucha informaci√≥n. Por ejemplo, Equipo
tiene un atributo (aunque no se lo vea definido expl√≠citamente) y se denomina estadio.
Esto se debe a que la relaci√≥n de asociaci√≥n es una implementaci√≥n de punteros: un objeto de
una clase apunta a uno o varios objetos de otra clase. Como se mencion√≥ anteriormente, la
cantidad de objetos a los que apunta la fuente se define mediante la multiplicidad. Hay varios
indicadores de multiplicidad. A continuaci√≥n, se los indican en la siguiente tabla:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/21c6719b-d500-4d07-8e3f-29c68292902b)

#### ¬øEs posible modificar la frase sem√°ntica de la asociaci√≥n?

Si, ve√°moslo con un ejemplo que
encara esta situaci√≥n y a la vez refuerza el modo de usar la multiplicidad

Ejemplo 2: la famosa lista de power ups que puede tener un personaje. En este caso nos
remitiremos a Legend of Zelda: A Link to the Past. Observe la siguiente imagen e intente modelar
las relaciones entre Link y el conjunto de power ups que puede usar en el juego:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/84a1f076-de76-473f-86da-5fc3b48a10d0)

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/8df71e1f-9405-4388-bf5a-fc34e95fb06b)

En este modelo podemos observar muchos aspectos muy importantes a considerar para quienes
empiezan en el modelado de clases. En primer lugar, observe que la clase de la cual se obtiene
un objeto que representa a Link se denominada MainCharacter. Es un error muy com√∫n
denominar a la clase con el nombre del personaje, es decir definir una clase que se llamar√≠a en
este caso Link; pero debe recordar que una clase es un molde del cual se generan objetos. El
proceso por el cual a partir de una clase se genera un objeto se denomina instanciaci√≥n; as√≠ un
objeto es una instancia de una clase. Por tanto, no ser√≠a correcto que la clase se llame como el
objeto.

En segundo lugar, observe que es posible cambiar la frase sem√°ntica por defecto de una
asociaci√≥n para expresar con mayor detalle la relaci√≥n conceptual entre dos clases. Por
ejemplo, entre MainCharacter e Item se expresa la relaci√≥n con la palabra ‚Äúcollects‚Äù; es decir
‚Äúobjetos de la clase MainCharacter coleccionan objetos de la clase Item‚Äù.
Esta relaci√≥n es refinada mediante la multiplicidad para indicar que ‚ÄúUn objeto de la clase
MainCharacter colecciona muchos objetos de la clase Item, pudiendo al inicio no poseer ning√∫n
item‚Äù, esto significa que el * del lado de Item en realidad es equivalente a 0..*.
Adem√°s, la relaci√≥n se puede refinar a√∫n m√°s mediante la especificaci√≥n del rol de los objetos
en la relaci√≥n. En este ejemplo, observe que el rol especifica el nombre del atributo que posee
o tiene la clase fuente, que en este caso es √≠tems. Entonces la relaci√≥n queda formalmente ‚ÄúUn
objeto de la clase MainCharacter colecciona 0 o muchos √≠tems‚Äù.

As√≠ las otras relaciones de asociaci√≥n presentes en este ejemplo son:
‚Ä¢ Un objeto de la clase MainCharacter usa 0 o muchos equipamientos
‚Ä¢ Un objeto de la clase MainCharacter adquiere 1 o muchas habilidades

#### ¬øPueden las asociaciones ser bidireccionales?

Si, esto se aplica esencialmente cuando se desea mantener un registro de la asociaci√≥n. En el
caso de los juegos se puede referir a la compra de premios mediante el uso de tarjeta. En estos
casos resulta interesante que tanto el comprador como el vendedor del premio tengan un
registro de la transacci√≥n (operaci√≥n de compra).
Ejemplo 3: Intente interpretar este diagrama de clases

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/5a9aa10d-af70-4a17-92df-ccea05db3f3c)

Puede observar que la clase principal es Compra, la cual mantiene un atributo de un objeto de
tipo Tarjeta. De la clase Premio se pueden instanciar objetos, tales como aquellos que d√≠a a d√≠a
sugiere el juego que se adquieran (o a√∫n incluso cuando no lo jugamos, especialmente en juegos
de celulares). Al autorizar una compra se guarda la fecha y‚Ä¶ aqu√≠ viene lo interesante, Compra
mantiene un conjunto de detalles (que ser√≠a el registro de cada una de las compras realizadas),
pero a la vez cada uno de esos detalles mantiene un registro de la compra a la que pertenece;
por tanto, es una relaci√≥n bidireccional. ¬øPor qu√© no se utiliza una relaci√≥n de asociaci√≥n desde
Compra a Premio directamente? Porque cada objeto de tipo Premio solo puede ser comprado
por un cliente √∫nicamente (algo similar a cuando compra un producto en un negocio: si bien hay
varios del mismo tipo en la consola o mostrador, ud selecciona alguno de ellos y es ese el
producto que adquiere). Adem√°s, el precio del premio puede cambiar en cualquier momento,
sin embargo, cuando se realiza la compra, ese precio se registra y no se cambia. Entonces,
Detalle se vuelve muy importante, porque permite llevar el registro a cu√°l compra pertenece,
cual es el premio comprado y con que precio adquiri√≥ el premio en el momento de la compra.
Por otra parte, un jugador podr√≠a comprar un premio y no usarlo hasta el momento que lo
requiera. Entonces ¬øde d√≥nde va a extraer el premio comprado si no es del detalle?

#### Entonces la bidirecci√≥n se logra con los navegadores a ambos extremos ¬øHay otra forma de representarla?

Si, curiosamente si no coloca la navegaci√≥n en ninguno de los extremos ser√° equivalente a una
bidirecci√≥n, es decir para el ejemplo anterior este ser√≠a su diagrama equivalente:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/e6dfd06b-33ce-470f-b9d4-adf159b8117d)

## La agregaci√≥n

La agregaci√≥n es una relaci√≥n de asociaci√≥n, pero jer√°rquica, en el sentido de que se establece
que una de las clases representa un ‚ÄúTodo‚Äù mientras que la otra clase representa a las ‚ÄúPartes‚Äù
del todo. La agregaci√≥n no es diferente de una asociaci√≥n y se suele preferir referenciarla como
asociaci√≥n.

Sin embargo, dado que el prop√≥sito de los modelos es reflejar una realidad de la manera m√°s
fiel posible dentro de los par√°metros de abstracci√≥n que se adopten, UML ofrece esta relaci√≥n
para indicar expl√≠citamente la relaci√≥n conceptual entre un ‚Äútodo‚Äù y sus ‚Äúpartes‚Äù, aunque luego
en la implementaci√≥n se interpreten de la misma manera.
En definitiva, esta relaci√≥n representa el hecho de que una clase puede constar de otras clases.
La jerarqu√≠a se expresa indicando la clase ‚Äútodo‚Äù en la parte superior, y los componentes
‚Äúpartes‚Äù por debajo de ella. Algunos autores no consideran lo anterior, debido a que la relaci√≥n
indica la clase ‚Äútodo‚Äù mediante un rombo o diamante denominado conector. Nuevamente se
vuelve a destacar que las clases agregadas son ‚Äúatributos‚Äù de la clase completa y, por lo tanto,
no se las expresa en manera expl√≠cita porque la relaci√≥n gr√°fica se encarga de ello.
Del lado de las ‚Äúpartes‚Äù la relaci√≥n puede o no finalizar en una flecha. Adem√°s, como la relaci√≥n
‚Äútodo‚Äù siempre se refiere a un elemento, no se coloca multiplicidad de este lado, mientras que
del lado ‚Äúpartes‚Äù se debe indicar expl√≠citamente la multiplicidad.
La frase sem√°ntica que referencia una relaci√≥n de agregaci√≥n es ‚Äúest√° formado/a por‚Äù. Esta
frase deber√≠a ayudar a confirmar o desestimar si una relaci√≥n de asociaci√≥n representa una
agregaci√≥n.

Ejemplo: Analice el diagrama de clases del ejemplo 3 y discierna si las relaciones de asociaci√≥n
indicadas confieren una agregaci√≥n, en cuyo caso actualice el diagrama de clases.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/a6ddab2b-7d87-41a7-abfb-c655b18868c5)

Bien, el diagrama de clases anterior se ha actualizado de la siguiente manera:
- Entre Compra y Tarjeta hay una asociaci√≥n. La compra ¬øest√° formada por la tarjeta? No.
Una compra no est√° f√≠sica o conceptualmente formada por una tarjeta, sino que registra
los datos de la tarjeta.

- Entre Compra y Detalle hay una asociaci√≥n. La compra ¬øest√° formada por detalles? Si,
una transacci√≥n (operaci√≥n de compra) necesariamente ‚Äúest√° formada‚Äù por detalles,
que son los que registran los premios comprados. Por tanto, aqu√≠, se coloca del lado
‚Äútodo‚Äù que es Compra el conector. As√≠, se debe leer ‚ÄúUn objeto compra est√° formado
por 1 o muchos detalles‚Äù. Observe adem√°s que en el conector no se coloca
multiplicidad.

- Finalmente, entre Detalle y Premio tambi√©n hay una asociaci√≥n. Como se indic√≥
previamente, en un detalle se registran los premios adquiridos, pero esto no significa
que f√≠sica o conceptualmente un detalle ‚Äúest√© formado‚Äù por un premio.

Tambi√©n observe que, con el objetivo de mantener la bidirecci√≥n de la navegaci√≥n, se ha
agregado un atributo denominado compra en Detalle, para explicitar la relaci√≥n de bidirecci√≥n.
Esto se ha realizado con el objetivo de mantener la claridad de lectura, aunque tambi√©n se
podr√≠a haber realizado de la siguiente manera

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/0fd8a87f-696c-4108-8670-eca8b554d32e)

As√≠, no hace falta colocar el atributo de tipo Compra en la clase Detalle, pero tenga cuidado de
malinterpretar la multiplicidad 1 que est√° debajo del conector: no pertenece a este; sino que
indica que un detalle usa o conoce su compra. Tambi√©n, debido a que **la navegabilidad del lado
de las ‚Äúpartes‚Äù es opcional**, el siguiente diagrama de clases tambi√©n ser√≠a v√°lido

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/7acf0ba7-94a3-42c8-9f18-a6d3db9b3fed)

Donde se mantiene la lectura de que ‚Äúun objeto de tipo Compra est√° formado por uno o m√°s
detalles‚Äù y que ‚Äúun detalle forma parte de una compra‚Äù. Adem√°s, un detalle usa o conoce su
compra. Esta forma, aunque parece clara podr√≠a causar una mala interpretaci√≥n, tal como
suced√≠a con el caso anterior, por lo que se suele en realidad usar esta otra forma de expresi√≥n

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/1d72bfe4-2cf1-4f4e-b1f5-bcb8b1d3d63e)
Mientras se cumpla la nomenclatura particular, puede utilizar cualquiera de estas formas.

## La composici√≥n

Es un tipo muy representativo de una agregaci√≥n, que expresa una relaci√≥n m√°s fuerte entre
el todo y sus partes. Cada componente puede pertenecer tan solo a un todo. En la composici√≥n
la clase ‚Äútodo‚Äù es responsable de la creaci√≥n y de la destrucci√≥n de la/s clase/s parte/s, y esta
√∫ltima no puede existir en alguna otra relaci√≥n al mismo tiempo. Por este motivo la composici√≥n
se denomina agregaci√≥n fuerte y la agregaci√≥n propiamente dicha agregaci√≥n d√©bil.
La clase compuesta debe garantizar que se crean todas sus partes y se fijan a la compuesta, antes
de que √©sta est√© por completo construida. En tanto exista la clase compuesta, se puede confiar
que ninguna de sus partes ser√° destruida por cualquier otra entidad, pero cuando se destruya
la compuesta, se deben destruir las partes, o puede eliminar en forma expl√≠cita las partes y
llevarlas hacia alg√∫n otro objeto. La relaci√≥n en UML se expresa mediante un s√≠mbolo similar al
de la agregaci√≥n, pero el conector en este caso es un diamante con color de relleno.

Ejemplo: Observe la siguiente imagen perteneciente al juego arcade The Fast & Furious
![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/4bab9c76-cf90-437f-b66c-ba7683c3a558)

Al inicio del juego y a medida que se van ganando carreras, es posible adquirir diversas partes
para mejorar el auto, entre los que se encuentra motores, nitro, neum√°ticos, alerones, etc.
Modele un diagrama de clases que establezca la relaci√≥n entre un auto y estas partes
![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/08736971-ab12-4f29-ae6c-4a184273284e)

err√≥nea, debido a que las partes se deben crear al momento de la instanciaci√≥n del objeto de
tipo Auto. Por lo tanto, lo correcto es leer literalmente ‚Äúun auto est√° formado por muchos
neum√°ticos‚Äù, aunque sabemos que en un an√°lisis necesitamos exactamente 4 neum√°ticos para
empezar, pero lamentablemente en UML ese tipo de multiplicidad ya no es v√°lido.
Finalmente podemos observar el caso del aler√≥n. En este caso podemos decir que ‚Äúun auto est√°
formado por un aler√≥n‚Äù o que un ‚Äúaler√≥n forma parte de un auto‚Äù. Sin embargo, podr√≠amos
correr una carrera sin el aler√≥n. Por ese motivo resulta claro que es una agregaci√≥n d√©bil, o
simplemente una agregaci√≥n. Y la multiplicidad expresa el hecho de que podr√≠a utilizar o no un
aler√≥n.

Nota: Finalmente para terminar con los conceptos vertidos hasta ahora, se puede expresar
gr√°ficamente la relaci√≥n que existe entre estas tres asociaciones con la siguiente gr√°fica, donde
la agregaci√≥n y la composici√≥n son subconjuntos de asociaci√≥n, lo que significa que son casos
espec√≠ficos de asociaci√≥n:

## La dependencia

Se lo suele definir como una **‚Äúasociaci√≥n de uso‚Äù**. Esto significa que expresa una situaci√≥n donde
**una clase A utiliza otra clase B, y donde un cambio en la especificaci√≥n de B puede afectar a A,
pero no necesariamente a la inversa.**
Por ese motivo la relaci√≥n se denomina de dependencia: **la clase A se denomina cliente,
mientras que la clase B se conoce como proveedor.** **Un objeto de la clase cliente depende de
un objeto de la clase proveedor para poder proporcionar o completar un servicio.** El s√≠mbolo
para una relaci√≥n de dependencia luce como una asociaci√≥n unidireccional, excepto que la l√≠nea
es punteada en lugar de continua.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/6e925d96-972e-4eee-9115-4915e2f699c0)

Esta situaci√≥n expresa que, a
diferencia de las anteriores relaciones
tratadas, la dependencia no opera con punteros. Es un recurso que sirve para mantener la estructura de clases con el menor nivel de
relacionamiento posible, es decir su objetivo consiste en contribuir en el dise√±o de un modelo
con bajo **acoplamiento.** El acoplamiento es una medida que indica cuan relacionadas est√°n las
clases. Si las clases est√°n muy relacionadas, se dice que tienen un alto acoplamiento, como
consecuencia de esto, cualquier cambio en ambas clases puede afectar seriamente a la otra
clase dificultando la posibilidad de modificar, actualizar o mejorar el funcionamiento del
sistema, lo cual no es deseado. El acoplamiento no se puede evitar, porque para que el sistema
realice su objetivo requiere que los objetos interact√∫en entre ellos, pero si se deber√≠a minimizar.

**Cada vez que se establece una relaci√≥n de asociaci√≥n, se establece un puntero entre dos clases.
Esto genera acoplamiento, y una relaci√≥n bidireccional genera a√∫n mayor acoplamiento.**

Por este motivo, **para evitar la bidirecci√≥n cuando se necesita una visibilidad invertida, se
aplican dependencias.** La dependencia** se implementa mediante un concepto denominado
visibilidad por par√°metros.** Esto significa que la operaci√≥n del cliente debe especificar que uno
de los par√°metros sea un objeto del servidor.

De esta manera el cliente ‚Äúvisualizar√°‚Äù el servidor √∫nicamente mientras dure el tiempo de vida
de la operaci√≥n, momento en el cual la visibilidad desaparece.

Entonces si bien existe el acoplamiento, es mucho m√°s d√©bil que aquel que se generar√≠a si se
estableciera una bidirecci√≥n como consecuencia la creaci√≥n de un puntero.
Las dependencias suelen aparecer cuando ud ya ha modelado su diagrama de clases y est√° a
punto de programarlo, o cuando quiere visualizar sus clases programadas en la forma de un
diagrama de clases. Esto significa que, si su diagrama de clases presenta dependencias, su
modelo est√° en etapas avanzadas y generalmente representan las clases programadas.

Ejemplo: Considerando lo que indica el apartado anterior, se debe procurar un modelado
intentando evitar usar relaciones bidireccionales. Entonces usando la dependencia, retome el
ejemplo 6 y elimine el acoplamiento generado por la bidirecci√≥n provocada por la agregaci√≥n
entre Compra y Detalle.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/7c60f668-8ef5-4918-b4b0-21acd6ba833f)

Observe que se ha reemplazado la agregaci√≥n bidireccional entre Compra y Detalle (que produce
un alto acoplamiento) por una asociaci√≥n unidireccional y una dependencia. Desde Detalle hacia
Compra se mantiene la asociaci√≥n, ya que es necesario que cada Detalle sepa a que Compra
pertenece. Mientras que del otro lado, Compra ahora no mantiene una relaci√≥n con Detalle, por
lo cual ¬øc√≥mo obtiene el total de la compra? Ahora posee una operaci√≥n denominada
obtenerTotal() que recibe por par√°metro un objeto de tipo BuscadorDeCompras. Esta clase
posee una colecci√≥n de objetos con todos los detalles existentes y adem√°s ofrece una operaci√≥n
por medio de la cual, si se le pasa el c√≥digo de la compra, podr√° devolver los detalles de esta. Al
recibir por par√°metro el buscador de compras, una compra podr√° consultar cuales son sus
detalles y de esa manera obtener el total de la compra. La relaci√≥n de dependencia sale de una
operaci√≥n de la clase ‚ÄúCliente‚Äù (la clase Compra) y para que se puede ejecutar requiere (o es
dependiente) de una clase ‚ÄúProveedora‚Äù (en este caso BuscadorDeCompras).

#### Un uso importante de la dependencia: la gesti√≥n de colisiones

En el mundo de los videojuegos, la interacci√≥n entre los objetos se conoce en primera instancia
como colisi√≥n. Esto es, dos o m√°s objetos se encuentran en un mismo espacio de la pantalla. La
interacci√≥n de cada uno de ellos puede ser diferente: hablar, golpear, defenderse, explotar, etc.
Si ud programa juegos usando un lenguaje de programaci√≥n puro y el paradigma orientado a
objetos, una manera de gestionar estas interacciones es crear clases que mantengan una
colecci√≥n de objetos del mismo tipo y usar la dependencia para determinar alguno de los objetos
de esta colecci√≥n colisiona con otros objetos.

Ejemplo: Observe la siguiente imagen. 
![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/a857fcb1-4ae3-409c-b65d-239469fa0df4)

Pertenece al juego Galaga. En este juego, al inicio de
cada nivel los enemigos se van ubicando en su posici√≥n original
en el espacio. Luego de que se forman empiezan a atacar ya sea
impactando sus disparos contra nuestra nave o choc√°ndola, lo
cual genera la p√©rdida de una vida.
Por otro lado, mientras se forman nosotros podemos atacarlos
dispar√°ndoles (tal como lo muestra la imagen). Cada disparo
que realizamos viaja por el espacio. Este disparo puede
impactar en un enemigo o desaparecer de la pantalla.
Realice un diagrama de clases que permita gestionar la
ubicaci√≥n de cada enemigo generado y evaluar si nuestros
disparos impactan contra alguno de ellos. De la misma manera
valide si nuestra nave choca con un enemigo o si el disparo de
uno de ellos impacta contra ella. 

El siguiente diagrama de clases muestra parcialmente el modelado solicitado.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/91c1307e-419c-4915-9d52-d80a568f4386)

Observe que hemos creado dos clases que ser√°n los contenedores de una colecci√≥n de objetos.
En primer lugar, se genera una colecci√≥n de enemigos, representada por la clase ListaEnemigos.
Esta clase posee un atributo denominado enemigos que es de tipo Enemigo.
En segundo lugar, se genera una colecci√≥n de los disparos que nuestra nave realiza, denominada
GestorDisparos, que posee un atributo denominado disparos que es de tipo Disparo.
Tanto Nave, como Enemigo y Disparo poseen un atributo denominado posici√≥n que es del Tipo
Position, el cual posee las coordenadas en el plano. Esta clase est√° etiquetada con el estereotipo
<<type>> por lo cual sabemos que es usada para generar un tipo de datos no existente en UML.

Ahora observemos el funcionamiento de este diagrama de clases:

- Un objeto de tipo Nave puede realizar una operaci√≥n denominada disparar(). Cada vez
que se dispara se agrega un nuevo objeto de tipo Disparo al gestor de disparos
(seguramente se invoca la operaci√≥n agregarDisparo()). Para poder realizar esto, la
√∫nica manera de hacerlo es que la operaci√≥n disparar() reciba como par√°metro el
gestor de disparos.

- Los disparos almacenados en el gestor de disparos van actualizando su posici√≥n
constantemente. Por ese motivo se debe invocar en todo momento la operaci√≥n
verificarImpacto() para determinar si el disparo desaparece de la pantalla o impacta con
un enemigo. Como se podr√° dar cuenta, para verificar si impacta con un enemigo, esta
operaci√≥n requiere poder disponer de la lista de enemigos. Es por esta raz√≥n que la
operaci√≥n mantiene una dependencia con ListaEnemigos. Entonces, verificarImpacto()
seguramente tomar√° cada disparo del Gestor de disparos y comparar√° su posici√≥n con
respecto a la posici√≥n de cada enemigo de la lista de enemigos, en cuyo caso en principio
eliminar√° al enemigo de su lista y el disparo tambi√©n desaparecer√° del gestor.

- Observe que Nave posee una operaci√≥n validarImpacto(). Esta operaci√≥n se encarga de
determinar si la nave choca con un enemigo. Por este motivo, se requiere de la lista de
enemigos y de esa manera se establece una dependencia. Nuevamente, este impacto
ser√° confirmado por el hecho de que la posici√≥n de la nave coincide con la posici√≥n de
un enemigo. Si esto sucede, en principio se disminuir√° la cantidad de vidas de la nave y
se eliminar√° el enemigo de su lista.

Con la informaci√≥n brindada por este ejemplo intente completar el diagrama de clases para que
posea los atributos y operaciones faltantes para validar que sucede si un disparo de los enemigos
impacta con nuestra nave.

#### Como afecta una clase degenerada la relaci√≥n de dependencia

Si la clase proveedor es una clase ‚Äúdegenerada‚Äù no se requerir√° definirlo como par√°metro en la
operaci√≥n del cliente. Una clase degenerada es aquella que no posee estado, su funci√≥n es
brindar un conjunto de operaciones que deber√≠an estar disponibles para todos los objetos.
Muchos lenguajes de programaci√≥n implementan las clases degeneradas como clases est√°ticas.

Si bien, las clases est√°ticas se estudiar√°n al momento de realizar la programaci√≥n de clases, se
puede adelantar que su objetivo fundamental es permitir que se puedan utilizar las operaciones
de una clase sin necesidad de crear previamente un objeto de esa clase.

Ejemplo: Con motivo de expresar en un diagrama de clases como afecta la dependencia el uso
de una clase degenerada se propone el siguiente ejemplo: En Java **Math** es un ejemplo de clase
degenerada, por lo cual hay una relaci√≥n entre la definici√≥n de clases degeneradas y las clases
que no poseen atributos (a menos que sean constantes) y sus operaciones son est√°ticos
(operaciones de clase, que estudiar√°n posteriormente). Suponga que desea modelar la
dependencia de una clase **Ecuacion** respecto del c√°lculo de una ecuaci√≥n cuadr√°tica al aplicar la
clase **Math**

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/0174806f-e42c-4511-add3-f8fb0208feaa)

**Observe que en Math se han definido operaciones de clase (est√°n subrayadas, tal como sucede
con los atributos de clase).**

La operaci√≥n resolverCuadratica() presenta un tipo de datos de retorno undefined, ya que
ninguno de los tipos de datos UML por defecto se ajusta al hecho de que debe devolver el valor
de ùë•1y ùë•2.

#### ¬øPero que es lo que le llama la atenci√≥n de esta dependencia?

Como habr√° notado, la operaci√≥n no recibe como par√°metro un objeto de la clase Math. Esto
se debe al hecho que Math es degenerada, por lo cual no se crean objetos a partir de ella, por
lo cual no hay forma de pasar un objeto como par√°metro. Pero al ser degenerada, es posible
utilizar sus operaciones sin ning√∫n problema: pow() permite obtener la potencia de un n√∫mero,
para lo cual recibe como par√°metro el n√∫mero y el exponente, devolviendo la potencia
generada; mientras que sqrt() devuelve la ra√≠z cuadrada de un n√∫mero. Si recuerda la ecuaci√≥n
que permite obtener las ra√≠ces de una ecuaci√≥n cuadr√°tica utilizan ambas operaciones.

# üü£ SEMANA 06

# INTRODUCCI√ìN
La herencia es una propiedad espec√≠fica del paradigma orientado a objetos. Este pilar constituye
tambi√©n una relaci√≥n entre clases. Una relaci√≥n permite establecer como interact√∫an las clases.
En el caso de la herencia esta relaci√≥n establece que una clase declara a otra clase como su
principal, tambi√©n se dice que una clase (denominada subclase) declara a otra como su
superclase. Esta declaraci√≥n se denomina herencia porque la subclase adquiere en forma
autom√°tica los atributos y operaciones de la superclase. De esta forma la subclase adem√°s de
los atributos y operaciones que posee adquiere los atributos y operaciones de la superclase. El
objetivo de este apunte ser√° describir las implicancias de utilizar esta propiedad y su forma de
modelado en UML.

## REPRESENTACI√ìN EN EL DIAGRAMA DE CLASES

En el diagrama de clases de UML la herencia posee un elemento de relaci√≥n propio basado en
una flecha que une la superclase con sus subclases. Sea el siguiente ejemplo
Figura 1. Ejemplo de herencia y tipos de vista de una herencia
![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/920cb973-9a1e-4b8c-aaef-1ca25d7b17eb)

Observe que se ha definido la clase Persona, la cual posee 3 atributos y una operaci√≥n. Luego se
han definido las clases Profesor y Estudiante. En principio la clase Profesor posee 2 atributos y 1
operaci√≥n, mientras que la clase Estudiante posee 1 atributo y ninguna operaci√≥n.
Sin embargo, la flecha que sale de cada una de estas clases hacia la clase Persona, indica que se
est√° estableciendo una relaci√≥n de herencia: La clase Persona se convierte en una superclase,
mientras que Profesor y Estudiante se convierten en subclases. Como consecuencia, ahora
Profesor posee 5 atributos y 3 operaciones, mientras que Estudiante posee 4 atributos y una
operaci√≥n.

La forma de la punta de la flecha de la relaci√≥n de herencia es muy clara: un tri√°ngulo sin relleno
que siempre apunta a la superclase.

## VISTAS DE UNA RELACI√ìN DE HERENCIA
Observe nuevamente la Figura 1. En ella se describe que existen dos formas de interpretar la
relaci√≥n de herencia dependiendo del punto de vista desde el cual se analice la relaci√≥n. Si se
parte desde la superclase hacia las subclases, la relaci√≥n de herencia describe un proceso de
especializaci√≥n: esto significa que cada una de las subclases pueden definir atributos y
operaciones que no son comunes entre ellas. Esto permite que cada una de estas subclases 
pueda brindar con mayor detalle sus propias caracter√≠sticas (atributos) y responsabilidades
(operaciones).
Si, por el contrario, analizamos la relaci√≥n de herencia desde las subclases hacia la superclase,
estaremos en presencia de un proceso de generalizaci√≥n. Esto es, en la superclase se definir√°n
los atributos y operaciones que son comunes o ‚Äúgen√©ricos‚Äù a todas las subclases. El proceso de
generalizaci√≥n-especializaci√≥n de la relaci√≥n de herencia deber√≠a poder brindarle un punto de
referencia para determinar si existe esta relaci√≥n entre dos clases

## VALIDACI√ìN DEL MODELADO DE UNA RELACI√ìN DE HERENCIA
En la figura 2, se intenta establecer una relaci√≥n de herencia entre la clase Casa y la clase Mueble,
donde la primera se convierte en la superclase y la segunda en la subclase. Se ha relacionado
dos clases indicando que Casa es la superclase de Mueble. Si realizamos un an√°lisis del proceso
de generalizaci√≥n ‚Äì especializaci√≥n, propuesto para estas clases, podemos detectar que
aparentemente la aplicaci√≥n de la relaci√≥n no tiene sentido: un mueble no hereda las cantidades
de habitaciones de una casa, esto es: un mueble no posee como atributo gen√©rico la cantidad
de habitaciones.
Figura 2. Una relaci√≥n de herencia inv√°lida
![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/35781299-5112-402f-a0c8-0c772b3d7dde)

Esto significa que al momento de decidir establecer una relaci√≥n de herencia entre dos clases se
debe verificar que la misma sea correcta.

## Frase semantica de la herencia

Para ello existe una frase que permite verificar si la relaci√≥n de herencia que se desea establecer
es correcta. Esta frase se denomina Frase Sem√°ntica y en el caso de la herencia es:

`¬ø<<La subclase>> es un tipo de/es un/es una <<La superclase>>?`

Si la respuesta es afirmativa entonces es correcto establecer la relaci√≥n de herencia, caso
contrario no se debe establecer la relaci√≥n de herencia.
En el ejemplo de la figura 2 la frase sem√°ntica se aplicar√≠a de la siguiente manera: ¬øEl mueble es
un tipo de Casa? o ¬øEl mueble es una casa? Evidentemente la respuesta es NO. Las casas poseen
muebles, pero los muebles no son casas.

De la misma manera para el ejemplo de la figura 1 se puede verificar:
- ¬øUn profesor es un tipo de Persona? La respuesta es SI, por lo tanto, fue correcto
establecer la herencia entre ambos
- ¬øUn estudiante es un tipo de Persona? En este caso tambi√©n es correcta la afirmaci√≥n.

## CONSECUENCIAS DE LA APLICACI√ìN DE LA HERENCIA
La herencia conlleva un conjunto de efectos secundarios que se deben tener en cuenta cuando
se decide aplicarla en un modelado de clases.

### Redefinir la visibilidad de los atributos de la superclase
Observe nuevamente la figura 1. Como se hab√≠a mencionado anteriormente la clase Profesor
hereda 3 atributos de la clase Persona. Ser√≠a razonable pensar que la subclase deber√≠a poder
manipular directamente esos atributos heredados, como si se hubieran definido dentro de la
misma clase Profesor. Pero esto no sucede. Si bien se crear√° un √∫nico objeto con todos los
atributos y operaciones definidos en Profesor y Persona, las clases dise√±adas son diferentes, con
una relaci√≥n definida pero diferentes al final de cuentas.

Recuerde que la visibilidad privada de los atributos y operaciones (-) indica que ninguna clase
externa puede acceder a esos atributos y operaciones. Por este motivo tanto en UML como en
los lenguajes de programaci√≥n se ha definido el modificador de acceso protected (protegido o
#) que mantiene la imposibilidad de manipulaci√≥n de atributos y operaciones de una clase a toda
clase ajena, salvo que sea una subclase. Por lo tanto, en realidad la Figura 1 deber√≠a tener la
siguiente forma

Figura 3. Herencia con atributos de la superclase con visibilidad protegida
![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/b237c1c6-1be1-4443-a68a-ac3f2f6e190c)


### La sobreescritura
Es aquella situaci√≥n donde una misma operaci√≥n se define tanto en la superclase como en la
subclase. Por ejemplo:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/eaab96bc-ea6d-47aa-9b0b-74cc58521ce4)

Observe que TrianguloIsosceles posee 2 operaciones con el mismo nombre y la misma lista de
par√°metros, por lo cual no es una sobrecarga de operaciones.
Formalmente se dice que ambas operaciones tienen la misma sem√°ntica (nombre de la
operaci√≥n) y la misma firma (lista de par√°metros de la operaci√≥n). Este es el √∫nico caso en el
cual los lenguajes de programaci√≥n permiten que un objeto posea dos operaciones iguales.
¬øPorque se permite esta situaci√≥n? En primer lugar, porque no se puede romper la caracter√≠stica
principal de una herencia: la subclase hereda los atributos y operaciones de la superclase.
En segundo lugar, si bien tenemos dos clases diferentes, por la relaci√≥n de herencia, la
instanciaci√≥n genera un √∫nico objeto. Es decir, cuando un lenguaje de programaci√≥n crea un
objeto de TrianguloIsosceles, el mismo poseer√° 3 atributos y 2 operaciones.
Ante esta situaci√≥n cabe la pregunta: Si se invoca la operaci√≥n getPerimetro() ¬øCu√°l de las dos
operaciones que posee se ejecutar√°?
Por defecto los lenguajes de programaci√≥n asumir√°n que la operaci√≥n que se ha definido en la
subclase es una ‚Äúespecificaci√≥n‚Äù de la definida en la superclase, por lo tanto, al poseer mayores
detalles la l√≥gica indica que se debe ejecutar, obviando de esta manera, la operaci√≥n definida
en la superclase. Este proceso se conoce como sobreescritura. Esto significa que existen ambas
operaciones en la subclase pero que al momento de invocar el nombre de la operaci√≥n se
ejecutar√° la de la subclase, porque sobre escribe o redefine la de la superclase; dando el efecto
o impresi√≥n de que la subclase solo posee el m√©todo definido en la subclase.

Formalmente los lenguajes de programaci√≥n seguir√°n los siguientes criterios coherentes con la
definici√≥n de herencia y sus procesos de especializaci√≥n y generalizaci√≥n:

- Si se crean objetos de la subclase, la operaci√≥n que se ejecutar√° ser√° la definida en la
subclase, ya que el proceso de especializaci√≥n asume que esta operaci√≥n redefine o
sobreescribe la de la superclase.

- Si se crean objetos de la superclase, la operaci√≥n que se ejecutar√° ser√° la definida en
esta, ya que el concepto de generalizaci√≥n supone que la superclase no conoce los
atributos y operaciones de las subclases. En esto caso no se aplica la sobreescritura.
La sobre escritura supone un conjunto de beneficios:

- Es posible crear una nueva forma de ejecutar una operaci√≥n sin necesidad de
modificarla o eliminarla. Se redefine su funcionamiento en la subclase sin afectar la
existente en la superclase. Esto facilita el mantenimiento del c√≥digo. Lo √∫nico que se
debe hacer es cambiar la instanciaci√≥n de la superclase por la de la subclase.

- Dado que la subclase hereda todos los atributos y operaciones de la superclase, no
deber√≠a ocurrir ning√∫n error de integraci√≥n de la subclase en el sistema, logrando de
esta manera mantener la integridad del sistema a la vez que se optimiza la funcionalidad
(y obviamente se podr√≠a agregar nueva funcionalidad en la subclase).

- Las operaciones redefinidas en una subclase pueden invocar la funcionalidad de la
operaci√≥n sobrescrita definida en la superclase. Es com√∫n que la propia operaci√≥n de la
subclase reutilice la funcionalidad de la operaci√≥n sobrescrita en superclase para luego
agregar una funcionalidad espec√≠fica, con lo cual se estima que se disminuye el tiempo
de desarrollo y se promueve la reutilizaci√≥n de funcionalidad.

Puede observar todos estos beneficios en acci√≥n en el video ‚Äúprogramaci√≥n de los beneficios de
la sobrescritura‚Äù.

### Clases abstractas

Debido a la herencia se establecen relaciones jer√°rquicas entre clases. Puede suceder que una
superclase sea tan gen√©rica que no tenga sentido instanciarla. En estos casos, se asume que la
superclase posee un alto nivel de abstracci√≥n, lo cual provocar√° que no sea posible definir
algunos o todos sus atributos ya que corresponden a alguna de sus subclases. Misma situaci√≥n
puede llegar a presentarse en las operaciones de esa clase. En este tipo de situaciones es
conveniente definir clases abstractas. Una clase abstracta es aquella que por definici√≥n no se
puede instanciar. Desde el punto de vista conceptual una clase abstracta es aquella que no
permite una clase que est√© m√°s alta en la jerarqu√≠a de relaciones, por lo tanto, no podr√° heredar
de otra clase definida por el desarrollador. Observe como se modela una clase abstracta en el
diagrama de clases:

Figura 5. Modelado de una clase abstracta

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/12e32ecf-2963-4940-b7b2-207251ca15d7)

Suponga que se crea un objeto de la clase Figura que se observa en la figura 5 y luego se invoca
la operaci√≥n obtenerPerimetro().
¬øC√≥mo se determinar√≠a cual de todas las posibles ecuaciones para obtener el per√≠metro de una
figura se utilizar√≠a?

Estamos ante una situaci√≥n en la cual el desarrollador no puede determinar la ecuaci√≥n que
debe programar para obtener su per√≠metro. Esto sucede porque Figura representa a todas las
figuras geom√©tricas, por lo cual crear un objeto de este tipo significar√≠a cometer un error en el
dise√±o del diagrama de clases.

En estos casos lo que se espera es que se generen objetos de las subclases √∫nicamente. En el
ejemplo de la figura 5, esto representar√≠a crear objetos de la clase Triangulo o Cuadrado, ya que
para estos objetos est√° establecida la forma en que obtienen sus respectivos per√≠metros.

As√≠, cuando no es posible crear un objeto de una clase, se dice que esa clase es abstracta. En
un diagrama de clases una clase abstracta se identifica con el nombre de la clase en cursiva (tal
como est√° representado en la figura 5, Figura es una clase abstracta).
Observe adem√°s que en esta clase abstracta se ha definido una operaci√≥n que tambi√©n est√° en
cursiva. ¬øSer√° una operaci√≥n abstracta? Exactamente esta operaci√≥n es abstracta.


#### ¬øQu√© es una operaci√≥n abstracta? 

Es una operaci√≥n que √∫nicamente define su interfaz, pero no
su implementaci√≥n. La interfaz de una operaci√≥n incluye el nombre, la lista de par√°metros y el
tipo de retorno de una operaci√≥n. La interfaz es lo que utiliza el protocolo de mensajes para
poder invocar operaciones. La implementaci√≥n de una operaci√≥n es el algoritmo que ejecuta la
acci√≥n de la operaci√≥n. Entonces, esto significa que una operaci√≥n abstracta no definir√° su
algoritmo.

¬øEntonces quien implementar√° ese algoritmo? Evidentemente lo implementar√°n sus subclases
a trav√©s de la sobreescritura de las operaciones.

Esto proporciona una manera elegante de dise√±ar clases y facilitar su programaci√≥n ya que:

1) Es posible indicar que una operaci√≥n en la superclase no posee implementaci√≥n (Por
ejemplo, en Figura la operaci√≥n obtenerPerimetro()).
2) Cuando se define una operaci√≥n abstracta SE OBLIGA a que las subclases sobreescriban
esa operaci√≥n y la implementen. Esto genera lo que se denomina un contrato entre la
superclase y la subclase por la cual la superclase encomienda a la subclase a
implementar la operaci√≥n definida como abstracta.

Nota importante: una clase abstracta no se puede instanciar, pero puede poseer operaciones
comunes (no abstractas) y atributos

## TIPOS DE HERENCIA

La herencia es simple cuando una subclase hereda √∫nicamente de una superclase. Por el
contrario, una herencia es m√∫ltiple si la subclase hereda de varias 2 o m√°s superclases.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/d6099472-3cd1-4fc5-883d-a009a215ea74)
Figura 6. Tipos de Herencia

En la figura 6 se puede observar que Class1 hereda √∫nicamente de Class, por lo cual estamos
ante una herencia simple. En cambio, Class2 hereda a la misma vez de Class y Class3, lo cual
significa que estamos ante una herencia m√∫ltiple.

## LA HERENCIA EN LOS VIDEOJUEGOS

En el paradigma orientado a objetos, si bien es posible que el desarrollador cree clases donde
se requiera la herencia, estas siempre convenientemente heredar√°n de **GameObject**. Esto se
debe a que al menos dispondr√°n de un atributo que represente la posici√≥n del objeto y una
operaci√≥n para renderizarlo (dibujar, redibujar pintar o refrescar).

Entonces ser√≠a conveniente crear una estructura similar a la siguiente:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/b4d67a74-7278-4758-8277-1ceae90d645e)
Figura 7. Esquema general de modelado de GameObjects

Como se puede observar, la figura 7 representa un esquema gen√©rico donde todos los
personajes del juego (MainCharacter y Enemie) as√≠ como sus recursos (PowerUp) son subclases
de una clase abstracta (GameObject) que posee un atributo position y una operaci√≥n abstracta
(display()). Esta operaci√≥n es sobrescrita por la implementaci√≥n correspondiente a cada
subclase, lo cual permitir√° renderizar el objeto en virtud de su posici√≥n.

Podr√≠a pensar en una jerarqu√≠a donde los gameobjects din√°micos puedan ser subclases
GameObject e incorporen una operaci√≥n move(). De esta clase a su vez heredar√≠an
MainCharacter y Enemie; mientras que PowerUp directamente heredar√≠a de GameObject
debido a que no se mueve.

La complejidad de la jerarqu√≠a la definir√° Ud. como dise√±ador.

## git
## INTRODUCCI√ìN
En esta secci√≥n estudiaremos el funcionamiento de Git y diferentes criterios para realizar un
correcto control de versiones.
Git es un software de control de versiones dise√±ado por Linus Torvalds. Fue pensado para que
el mantenimiento de versiones de aplicaciones (cuando tienen un gran n√∫mero de archivos de
c√≥digo fuente) sea eficiente y confiable. Su prop√≥sito es llevar registro de los cambios en
archivos de computadora y coordinar el trabajo que varias personas realizan sobre archivos
compartidos.

## ¬øQU√â ES UN SISTEMA DE CONTROL DE VERSIONES?

Imaginemos que comenzamos un nuevo proyecto que consiste en solo un archivo fuente. Lo
m√°s probable es que se puedan deshacer los cambios que se hicieron durante esa jornada.
Al d√≠a siguiente, se contin√∫a con el desarrollo y se mejora el archivo, pero, en el intento, el
programa comienza a presentar errores. Necesitamos volver a una versi√≥n anterior del
proyecto, donde no exist√≠a el error. Sin embargo, al no contar con un Control de Versiones, no
contamos con respaldo de las versiones previas.

Se denomina Control de Versiones a la gesti√≥n de los diversos cambios que se realizan sobre los
elementos de alg√∫n producto o una configuraci√≥n de este. Una versi√≥n, revisi√≥n o edici√≥n de un
producto, es el estado en el que se encuentra el mismo en un momento dado de su desarrollo
o modificaci√≥n.

## ¬øQUE ES EL TRABAJO COLABORATIVO?

Es un modelo de desarrollo basado en la disponibilidad p√∫blica del c√≥digo y la comunicaci√≥n v√≠a
Internet. Este modelo se hizo popular a ra√≠z de su uso para el desarrollo de Linux en 1991.
Tomando como contexto a Git, podr√≠amos decir que el desarrollo colaborativo proporciona
herramientas para que un gran n√∫mero de individuos puedan hacer desarrollos en conjunto de
una manera m√°s f√°cil, menos propensa a errores y r√°pida de implementar.

## ¬øC√ìMO FUNCIONA GIT?: El CONCEPTO DE GRAFO Y UNA BREVE DESCRIPCI√ìN DE LA TEORIA DE GRAFOS

Anteriormente se ha comentado que un software de VCS es una implementaci√≥n de una
especificaci√≥n para realizar control de versiones. Existen diversas especificaciones. Una de ellas,
concretamente la que adopta el software Git est√° basada en el concepto del grafo.

En matem√°ticas y ciencias de la computaci√≥n, un grafo (del griego grafos: dibujo, imagen) es un
conjunto de objetos llamados v√©rtices o nodos unidos por enlaces llamados aristas o arcos que
permiten representar relaciones binarias entre elementos de un conjunto. Son el objeto de
estudio de la Teor√≠a de Grafos.

Un grafo se representa gr√°ficamente como un conjunto de puntos (v√©rtices o nodos) unidos por
l√≠neas (aristas). Desde un punto de vista pr√°ctico, los grafos permiten estudiar las interrelaciones
entre unidades que interact√∫an unas con otras.

Por ejemplo: una red de computadoras puede representarse y estudiarse mediante un grafo, en
el que los v√©rtices representan terminales y las aristas representan conexiones (las cuales, a su
vez, pueden ser cables o conexiones inal√°mbricas). 

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/98eb3851-2277-4cf8-add3-34f1ae7cc17e)

Un grafo est√° compuesto por:

- Aristas: son las l√≠neas con las que se unen los v√©rtices de un grafo.
- Aristas adyacentes: 2 aristas son adyacentes si convergen en el mismo v√©rtice.
- Aristas paralelas: son dos aristas conjuntas si el v√©rtice inicial y final son el mismo.
- Arista c√≠clica: es la arista que parte de un v√©rtice para entrar en s√≠ mismo.
- Cruce: son 2 aristas que cruzan en un mismo punto.
- V√©rtices: son los elementos que forman un grafo. Cada uno lleva asociada una valencia
caracter√≠stica seg√∫n la situaci√≥n, que se corresponde con la cantidad de aristas que
confluyen en dicho v√©rtice.
- Camino: se denomina camino de un grafo a un conjunto de v√©rtices interconectados por
aristas. Dos v√©rtices est√°n conectados si hay un camino entre ellos

**Git no piensa ni almacena sus datos de esta manera. Git considera sus datos como un conjunto
de snapshots (instant√°neas) de un mini sistema de archivos. Git maneja sus datos como una
secuencia de copias instant√°neas.**

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/e8929f7c-5055-45bb-abac-00547982e657)

## ESTADOS Y SECCIONES DE UN REPOSITORIO GIT

Esto es lo m√°s importante que debes recordar acerca de Git si quieres que el resto de tu proceso
de aprendizaje prosiga sin problemas. Git tiene tres estados principales en los que se pueden
encontrar tus archivos: confirmado (committed), modificado (modified), y preparado (staged).
1) Confirmado (Commited): significa que los datos est√°n almacenados de manera segura
en tu base de datos local.
2) Modificado (Modified): significa que has modificado el archivo pero todav√≠a no lo has
confirmado a tu base de datos.
3) Preparado (Staged): significa que has marcado un archivo modificado en su versi√≥n
actual para que vaya en tu pr√≥xima confirmaci√≥n.

Esto nos lleva a las tres secciones principales de un proyecto de Git: El directorio de Git (.git
directory), el directorio de trabajo (working directory), y el √°rea de preparaci√≥n (staging area):

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/e89c15fa-5dbd-4791-b570-3d0f2bb835a0)


El directorio de Git es donde se almacenan los metadatos y la base de datos de objetos para tu
proyecto. Es la parte m√°s importante de Git, y es lo que se copia cuando clonas un repositorio
desde otra computadora.
El directorio de trabajo es una copia de una versi√≥n del proyecto. Estos archivos se obtienen de
la base de datos comprimida en el directorio de Git (haciendo un Checkout the Project), y se
colocan en disco para que los puedas usar o modificar.
El √°rea de preparaci√≥n es un archivo, generalmente contenido en tu directorio de Git, que
almacena informaci√≥n acerca de lo que va a ir en tu pr√≥xima confirmaci√≥n. A veces se le
denomina √≠ndice (‚Äúindex‚Äù), pero se est√° convirtiendo en est√°ndar el referirse a ella como el √°rea
de preparaci√≥n.

El flujo de trabajo b√°sico en Git es algo as√≠:
1) Modificas una serie de archivos en tu directorio de trabajo.
2) Preparas los archivos, a√±adi√©ndolos a tu √°rea de preparaci√≥n.
3) Confirmas los cambios, lo que toma los archivos tal y como est√°n en el √°rea de
preparaci√≥n y almacena esa copia instant√°nea de manera permanente en tu directorio
de Git.

Lo anterior esquem√°ticamente se representa de la siguiente manera:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/25043140-1fc7-4f01-9fed-983416309f54)

Donde se observa que el pasaje de un estado a otro se realiza a trav√©s de comandos de Git. De
manera resumida para pasar del working directory al stagig area se utiliza el comando git add,
mientras que para pasar de esta √∫ltima √°rea al .git directory hay que realizar un git commit.
Si una versi√≥n concreta de un archivo est√° en el directorio de Git, se considera confirmada
(committed). Si ha sufrido cambios desde que se obtuvo del repositorio, pero ha sido a√±adida al
√°rea de preparaci√≥n, est√° preparada (staged). Y si ha sufrido cambios desde que se obtuvo del
repositorio, pero no se ha preparado, est√° modificada (modified).

## GIT STATUS
Tomando como referencia el ejemplo de proyecto sobre el que se ha realizado el seguimiento
mediante git init, podemos verificar que, aunque posee el archivo .pde que Processing crea
dentro del directorio, este resultar√° desde el punto de vista de Git como un nuevo elemento
dentro del proyecto. Esto lo comprobaremos al ingresar el siguiente comando.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/80bf3907-5634-4f6f-84ee-fccac34d8109)

El comando nos brinda mucha informaci√≥n:

1) En primer lugar, nos indica que estamos parados en la Rama Principal, es decir el camino
que por defecto Git realiza el seguimiento.
2) En segundo lugar, nos indica que no hemos realizado ninguna confirmaci√≥n (commit).
Los commits permiten confirmar los cambios realizados cuando los pasamos desde el
staging area al .git drectory o repositorio. En este ejemplo es natural, porque reci√©n
hemos creado el directorio.
3) En tercer lugar, nos informa que ha detectado archivos que no se est√°n siguiendo
(untracked files). Es decir, se han creado nuevos archivos, o aquellos existentes
presentan modificaciones con respecto a la versi√≥n almacenada en el directorio de git.
Para este ejemplo, significa que HolaMundoProcessing.pde est√° en el estado (modified),
o lo que es lo mismo se halla en el working directory. Esto se debe a que Git observa que
hay un archivo en el working directory del cual no encuentra una versi√≥n anterior
(instant√°nea o snapshot) en el .git directory. Por lo tanto, Git no lo va a incluir hasta
que se lo indiquemos expl√≠citamente.

A su vez, brinda informaci√≥n sobre como poder colocar este cambio en el staging area mediante
el comando git add. Esquem√°ticamente podemos visualizar esta situaci√≥n de la siguiente
manera:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/54797494-1d46-47b7-b182-5ca61822c66f)

## GIT ADD

Se utiliza para comenzar a rastrear un archivo; por ejemplo puedes ejecutar lo siguiente:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/b9f7f736-35d9-4fdd-871c-0f83488d49bc)

Puede observar, adem√°s, que luego de ejecutar el comando, una nueva consulta de estados nos
informa que existen cambios a ser confirmados. Espec√≠ficamente el cambio radica en que existe
un nuevo archivo a seguir (new file: HolaMundoProcessing.pde).
Esto significa que el comando add ha cambiado el estado del archivo, pas√°ndolo de modified a
staged:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/15caa9f9-9575-4b05-be3f-4e44a5b2ad3e)

El comando git add puede recibir tanto una ruta de archivo como de un directorio; si es de un
directorio, el comando a√±ade recursivamente los archivos que est√°n dentro de √©l.
Si generamos un commit en este punto, la versi√≥n del archivo en el momento en que hayamos
ejecutado el comando git add va a permanecer en el snapshot hist√≥rico anterior.
Pero si modificamos y guardamos los cambios del archivo.

## GIT COMMIT

Una vez que el/los archivos/directorios se encuentran en el √°rea de preparaci√≥n (staging area),
estamos listos para confirmar los cambios ejecutando un commit de la siguiente manera:

Sin embargo, vamos a recomendar que se realice un commit con definici√≥n de un mensaje, para
lo cual se utiliza la opci√≥n -m. Para nuestro ejemplo, usaremos lo siguiente:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/147f4d5a-62e2-4f42-829e-2457243e97b5)

Como puede notar se genera una respuesta que indica que se ha agregado al archivo 5 nuevas
l√≠neas y que se han confirmado los cambios.
Espec√≠ficamente nos brinda informaci√≥n acerca de:
- La rama (branch) donde confirmamos los cambios (main)
- El identificador SHA-1 del commit (6180c2c)
- Cu√°ntos archivos fueron modificados
- Estad√≠sticas acerca de las l√≠neas que fueron insertadas o removidas en el commit.
Cada vez que hagamos un commit estaremos generando una nueva versi√≥n del proyecto, o
snapshot, la cual podemos revertir o comparar luego.

## GIT LOG

Antes de continuar viendo otras opciones de git commit, resulta conveniente estudiar el
comando git log. Luego de haber creado varios commits, o mismo si hemos clonado un
repositorio con un historial de commits existente, probablemente queramos mirar hacia atr√°s
para ver qu√© ha pasado en el repositorio. Con el comando git log logramos esto:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/e94e0015-4965-443a-a656-eebb2c954664)

Por defecto, sin par√°metros, git log lista los commits hechos en un repositorio en orden
cronol√≥gico inverso; esto es, el commit m√°s reciente se ver√° primero. Como podemos ver, este
comando enumera cada commit con su identificador SHA-1, el nombre de autor e email, la fecha
de escritura y el mensaje del commit. 

Este comando viene con muchos atajos y par√°metros que podemos agregar para que la salida
en la l√≠nea de comandos no sea tan abundante. Particularmente las opciones de --oneline y --
graph son sumamente √∫tiles respectivamente, para mostrar informaci√≥n abreviada sobre cada
commit y para poder ver un gr√°fico ASCII mostr√°ndonos nuestro historial de commits:

# üü† SEMANA 07

## CONCEPTO INTERFACES

En las clases se definen operaciones. Estas operaciones se definen considerando el nombre de
la clase, el nombre de la propia operaci√≥n, los par√°metros que reciben y su valor de retorno.
Estos 3 √∫ltimos elementos constituyen ‚ÄúLa firma de la operaci√≥n‚Äù.
El conjunto de todas las firmas definidas en una clase (y por consecuencia en el objeto) se
denomina ‚ÄúInterfaz del objeto‚Äù. La interfaz de un objeto engloba al conjunto de solicitudes que
se le puede enviar al objeto (Del libro
Design Patterns: Elements of Reusable
Object-Oriented Software).

En criollo lo anterior indica: defina las operaciones disponibles en la clase. Bien‚Ä¶y ahora ¬øC√≥mo
pueden acceder a esas operaciones OTROS objetos?

1) Hay que definir un mecanismo para que esas operaciones est√©n disponibles (lo que se
denomina Interfaz del objeto).
2) Esa interfaz del objeto es la propia sem√°ntica (el nombre del m√©todo) y firma de la
operaci√≥n (el conjunto de par√°metros del m√©todo); es decir para acceder a la operaci√≥n
se debe hacer referencia al nombre de la operaci√≥n, sus par√°metros y tipo de retorno.
3) La forma en que un objeto se comunica con la interfaz de otro objeto es a trav√©s del
protocolo de mensajes, el cual seg√∫n nuestro lenguaje de programaci√≥n (Processing) se
define como: nombreDelObjeto.nombreDelM√©todo(parametros);

## REALIZANDO UNA APROXIMACI√ìN DESDE LA EXPERIENCIA DEL MODELADO

En la programaci√≥n orientada a objetos, a veces es √∫til definir **QU√â** debe hacer una clase, pero
no **C√ìMO** lo har√°. Para realizar lo anterior podemos recurrir a dos estructuras:

1) Por un lado, las clases abstractas, las cuales vimos c√≥mo se definen. Estas clases tienen
la particularidad de que en ellas se pueden definir tanto operaciones ‚Äúnormales o
concretas‚Äù como las denominadas operaciones abstractas. Al momento de llevar un
diagrama de clases modelado a la etapa de programaci√≥n, las operaciones concretas
poseen implementaci√≥n. Es decir, el desarrollador deber√° codificar el algoritmo de esa
operaci√≥n. En cambio, las operaciones abstractas no poseen implementaci√≥n. Esto
significa que alguna subclase de la clase abstracta deber√° proporcionar la
implementaci√≥n de las operaciones abstractas definidas en la superclase abstracta.
En pocas palabras una clase abstracta puede poseer operaciones abstractas (aquellas
en la que especifica la sem√°ntica y la firma, pero no su implementaci√≥n)
Un ejemplo cl√°sico de la bibliograf√≠a es el siguiente

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/7fdd35c9-9c2e-4440-97e6-3ef14a7b4b7d)

Tenemos una superclase abstracta. En esta clase se pueden definir atributos como en
cualquier clase. Tambi√©n posee una operaci√≥n concreta (mover()), que recibe dos
par√°metros para cambiar la posici√≥n de la figura en un espacio 2D. La operaci√≥n
**calcularSuperficie()** es abstracta. Resulta claro que no posee implementaci√≥n
porque sin saber el tipo de figura no es posible utilizar una ‚Äúformula‚Äù para calcular esta
operaci√≥n. Se hace necesario definir subclases, y que cada una de ellas sobre escriba
esta operaci√≥n para establecer la implementaci√≥n correcta.

2) Si bien las clases y operaciones abstractas son √∫tiles, es posible llevar este concepto un
paso m√°s all√°. Tanto en UML como en los principales lenguajes de programaci√≥n, es
posible separar por completo la interfaz de una clase de su implementaci√≥n, utilizando
interfaces.

¬øPor qu√© querr√≠amos hacer esto?

Las interfaces sirven para representar ‚Äúcontratos‚Äù. Establecen que operaciones deber√°n
implementar las clases que adhieran a este contrato. De esta manera, si una clase
adhiere a este contrato, debe respetarlo, por ende, deber√° implementar el c√≥digo de
todas las operaciones que est√°n definidas en ese contrato.

¬øY esto para que nos sirve?

Separar la interfaz de su implementaci√≥n en t√©rminos de ingenier√≠a del software implica
minimizar el acoplamiento y maximizar la cohesi√≥n. Para no entrar en detalles de estos
dos conceptos, suponga que debe desarrollar una aplicaci√≥n que ordena una lista de
cualquier tipo objetos. Ud podr√≠a crear algo como esto:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/3c44e852-69c4-4620-8543-d1ea10faf323)

Observe varias cosas:
Por empezar se define una interface denominada Comparable. Toda clase que
implemente esta interfaz establece un contrato por el cual esa clase debe tener
implementado una operaci√≥n **compareTo()** que compara ese objeto contra otro
objeto, devolviendo un valor que indica el resultado de la comparaci√≥n (por ejemplo
podr√≠a ser: negativo, 0 o positivo si el objeto actual es menor, igual o mayor
respectivamente al objeto comparado).
Probablemente si Ud define una clase Persona no piense que deba poseer una
operaci√≥n **compareTo()** como algo com√∫n que se le pedir√≠a a una persona. Pero el
contrato establece claramente que debe implementar esa operaci√≥n. De all√≠ la primera
utilidad de una interface.

En segundo lugar, si observa la clase OrdenacionBurbuja notar√° que posee un
atributo que es una lista o un arreglo de objetos comparables, y adem√°s posee una
operaci√≥n **ordenarLista()**. Ud. podr√≠a agregar otra clase que ordene utilizando
otra t√©cnica de ordenaci√≥n (por ejemplo, debido a un requisito no funcional, respecto
del tiempo de respuesta del m√©todo de ordenaci√≥n, es decir que se necesita un m√©todo
m√°s r√°pido de ordenaci√≥n que el de burbuja) sin casi tocar todo el resto del modelo.
Tambi√©n podr√≠a agregar nuevos mecanismos de comparaci√≥n para la persona, lo cual
agrega versatilidad; algo que no posee Factura, ya que solo posee un mecanismo de
comparaci√≥n, que ser√≠a por el monto. Todo gracias a la combinaci√≥n del uso de
interfaces y clases abstractas.
En tercer lugar, aparece una nueva relaci√≥n, que es la dependencia. La operaci√≥n
**compareTo()** no puede llevarse a cabo si no recibe por par√°metro un objeto de tipo
Object. Esta relaci√≥n se utiliza para evitar que una clase deba tener un atributo de
otra clase, as√≠ en este caso **Comparable** no est√° ligado a **Object** (no conoce a
Object, o no tiene referencia a Object, o no apunta a **Object**). Adem√°s, como
**Comparable** es una interfaz, por definici√≥n no posee atributos.

## SOBRE LA DEFINICI√ìN DEL CONTRATO

En este contrato, la interfaz DEFINE:
- Los nombres de las operaciones
- Su tipo de retorno
- El tipo y cantidad de par√°metros que reciben las operaciones
En este contrato, la interfaz NO DEFINE:
- Implementaciones (en una interfaz todas las operaciones son abstractas)
- Atributos
Al igual que las clases abstractas, las interfaces no se pueden instanciar.
Generalmente se las confunde con clases abstractas, aunque la diferencia principal reside en
que para que una clase herede de otra abstracta debe seguir cumpli√©ndose la frase sem√°ntica
**‚Äúes un tipo de‚Äù**, y adem√°s las operaciones que se definan tienen un sentido asociado al nombre
de la clase; mientras que una clase puede implementar una o varias interfaces, simplemente con
el objetivo de indicar el contrato de operaciones que debe cumplir.
En adici√≥n a lo indicado en el p√°rrafo anterior, mientras que la forma en que se lee la relaci√≥n
de una clase cualquiera con su clase abstracta es **‚Äúes un tipo de‚Äù**, en las interfaces la lectura es
**‚Äúse comporta como‚Äù.**
  
Por √∫ltimo, hay que recordar que las interfaces no son clases

## REPRESENTACI√ìN EN UML

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/f810bf6e-6c3e-413c-ae86-94d31a77c160)

Podemos notar varias cosas (que tambi√©n est√°n reflejadas en el primer ejemplo):
- El estereotipo <<interface>> se antepone al nombre de la interfaz
- Se suele denotar el nombre de la interfaz con la letra I, no siendo obligatorio, pero es
com√∫nmente aceptado dentro del desarrollo de software. Sobre todo, entre los
programadores.
- El nombre de la operaci√≥n est√° en cursiva para resaltar que es abstracto, aunque
algunos autores no lo ponen, por cuanto se sobre entiende al estar definido dentro de
una interface.
- La relaci√≥n es similar al de la generalizaci√≥n, pero la l√≠nea es punteada, y tiene por
nombre realizaci√≥n o implementaci√≥n.

## OTRAS UTILIDADES DE LAS INTERFACES

Dado que las interfaces permiten definir contratos √∫nicamente sobre el comportamiento de las
clases pueden resultar √∫tiles para resolver de manera elegante problemas de dise√±o.
Por ejemplo, suponga que crea un videojuego donde utilizar√° diferentes personajes que son
animales. Suponga que utiliza aves como personajes, aqu√≠ sabe que todas las aves comen, pero
no todas las aves vuelan, y justo uno de sus personajes es un ping√ºino. En t√©rminos de dise√±o,
podr√≠as decidir crear una clase abstracta Ave con el m√©todo comer() y luego crear una subclase
AveVoladora y que esta posea el m√©todo volar(). As√≠ por ejemplo un Halcon heredar√° de
AveVoladora, mientras que Ping√ºino de Ave.
Pero, si reflexiona un poco m√°s, esta decisi√≥n se realiza sobre el comportamiento de las aves.
Por lo cual una soluci√≥n m√°s elegante ser√≠a la siguiente:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/2eb7e92e-96bc-4797-9cdc-3bb5bf43bd89)

Con esto establecemos un contrato √∫nicamente con las aves que son voladoras, o dicho de otra
manera que tienen comportamiento de voladoras.

## CONCEPTO DE POLIMORFISMO
## Introducci√≥n

El polimorfismo es una propiedad del paradigma de objetos, en este caso la √∫ltima que estamos
estudiando (las anteriores fueron abstracci√≥n, encapsulaci√≥n y la herencia). Esta propiedad permite
trabajar de manera general, en lugar de trabajar de manera espec√≠fica. Trabajar de manera general
permite facilitar la tarea de escalabilidad de la aplicaci√≥n orientada a objetos. La escalabilidad hace
referencia a la posibilidad de poder ir aumentando la complejidad y los servicios que provee la
aplicaci√≥n.

El tipo de polimorfismo que estudiaremos ser√° el polimorfismo limitado. Este tipo de polimorfismo
requiere de la presencia previa de la herencia simple. La herencia simple implica que una clase solo
puede heredar a lo sumo de una √∫nica otra clase.
Esta particularidad nos permitir√° escribir programas que procesan objetos que compartan la misma
superclase (ya sea de manera directa o indirecta [esto es usar interfaces]) como si todos fueran
objetos de la superclase. Suponga que crea una aplicaci√≥n que deba simular el movimiento de
varios tipos de animales para un juego con vista desde arriba. En este tipo de juegos el movimiento
ser√° en dos dimensiones. Las clases Pez, Rana y Ave representan los tipos de animales que se
est√°n evaluando programar. 
Adem√°s estas clases heredan de la clase Animal, la cual contiene una
operaci√≥n denominada mover() que a su vez devuelve la posici√≥n actual del animal luego de realizar
el movimiento (esto es los valores x e y de una plano). Como puede imaginar cada tipo de animal
se mueve de manera diferente, entonces lo m√°s conveniente ser√≠a que cada uno de ellos sobre
escriba la operaci√≥n mover, lo cual en t√©rminos del diagrama de clases ser√≠a equivalente a

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/a45a10a7-5de5-4158-b2a7-7b264adaa692)

Entonces podemos afirmar que no solamente se requiere la herencia simple, sino que adem√°s debe
usarse la sobreescritura de las operaciones para poder aplicar el polimorfismo. Llegado a este
punto, ¬øqu√© es el polimorfismo?

Suponga que el programa mantiene un arreglo de tipo Animal, donde cada una de las referencias
de este tipo corresponden a alguna de las subclases. Entonces para simular el movimiento de cada
animal, a cada elemento del arreglo se le env√≠a el ‚Äúmismo mensaje‚Äù, es decir se invoca la operaci√≥n
mover() del objeto de tipo Animal. Pero por la sobreescritura, el resultado al ‚Äúmismo mensaje‚Äù 
pender√° de la implementaci√≥n que se realiz√≥ en la operaci√≥n realizada en cada clase en
particular. Esta capacidad para responder a un mismo mensaje de manera diferente que poseen los
objetos se denomina polimorfismo, espec√≠ficamente polimorfismo limitado, el cual
esquem√°ticamente para este ejemplo en particular estar√≠a representado de la siguiente manera:


![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/b8886815-99e9-4083-bd4c-031c83298f75)

Con este esquema se puede confiar en que cada objeto sabr√° como ‚Äúhacer lo correcto‚Äù (es decir,
lo apropiado para ese tipo de objeto) respecto de la manera en que debe realizar la operaci√≥n
mover() de manera independiente a los otros tipos de animales.
En este esquema, observe que en este tipo de polimorfismo el efecto polim√≥rfico es disparado por
un m√©todo que recibe en dependencia un objeto de la superclase, desde el cual se invoca el m√©todo
sobreescrito. Esto significa que para obtener el resultado de las ‚Äúmuchas formas diferentes‚Äù que
adquiere un mismo mensaje (en este aso simularMovimeintoAnimal) la superclase debe ser
instanciada por medio de alguna de sus subclases, ya que de no ser as√≠ ser√≠a imposible que se
manifieste la sobreescritura.

De manera formal, el polimorfismo es la propiedad del paradigma orientado a objetos que posibilita
que un objeto responda de diferente manera a un mismo mensaje. Espec√≠ficamente, el
polimorfismo limitado es aquel en el que el comportamiento polim√≥rfico se obtiene al instanciar
un objeto de una clase a partir de una de sus subclases, de tal manera que la sobreescritura genera
el efecto de una respuesta diferente al mismo mensaje.

## Ventajas estructurales del polimorfismo

Gracias a polimorfismo es posible extender con facilidad los requerimientos de la aplicaci√≥n
(escalabilidad): pueden agregarse nuevas clases con solo modificar un poco (o nada) las porciones
generales del programa, siempre y cuando las nuevas clases sean parte de la jerarqu√≠a de herencia
que el programa procesa en forma gen√©rica.

Observe los videos ‚ÄúLa l√≥gica del polimorfismo explicada con Minecraft y ‚ÄùLa mejor t√©cnica para
programar videojuegos sin perder el tiempo: polimorfismo. Luego realice en grupo la actividad
solicitada.




