## Apuntes de Fundamentos de la Programaci√≥n Orientado a Objetos
###### _No olvides darle una estrellita a este repositorio :D  -_ <img src="https://i.ibb.co/0nX0bNR/Screenshot-2024-05-07-164050.png" alt="Screenshot-2024-05-07-164050" border="0" height="30em" align="center">
<img src="https://i.ibb.co/ryRMhP0/fpoo.png" alt="fpoo" border="0" height="370em"><br> 
##
# üü¢ SEMANA 01
### **üòµ‚Äçüí´ PROBLEMA Y SOLUCI√ìN**
<br>

| |
|---|
| **_"La programaci√≥n surge como respuesta a la necesidad de resolver problemas mediante la ejecuci√≥n de instrucciones por un ordenador"_**|

<br>

### **üìö CONCEPTO DE PROBLEMA**

Un problema en **t√©rminos generales** se puede conceptualizar de las siguientes maneras: 
- Es un asunto o cuesti√≥n que se debe solucionar o aclarar.
- Una contradicci√≥n o un conflicto entre lo que es y lo que debe ser.
- Una dificultad o un inconveniente para la consecuci√≥n de un fin.
- Un disgusto, una molestia o una preocupaci√≥n.
<br>

El  concepto de problema derivado de la Ingenier√≠a en su libro Introducci√≥n a la ingenier√≠a (1998) el autor **Krick afirma** que: <br>
| |
|---|
|**_‚ÄúUn problema proviene del deseo de lograr la transformaci√≥n de un estado en otro‚Äù_**| 
<br>

Ejemplo:
<br>
Si una persona est√° enferma **(Estado A)** , nace la necesidad o deseo de mejorar la salud; es decir
pasar a que esa persona est√© saludable **(Estado B)**, por medio de un tratamiento, operaci√≥n o
cualquier otra acci√≥n que produzca el cambio de estado. 
<br>
ejemplo 2:
<br>
Se necesita ense√±ar a ni√±os a cruzar la calle (**Estado A:** ni√±os no saben cruzar la calle) de una
manera entretenida y educativa (**Estado B:** los ni√±os aprendieron a cruzar la calle).

### **üß© PARTES DE UN PROBLEMA**
Todo problema est√° compuesto, conceptualmente, por tres partes o aspectos:
1. **Un estado inicial**, **‚ÄúA‚Äù** inferior, que se manifiesta por medio de s√≠ntomas, efectos o
consecuencias producto de una carencia, necesidad, deseo o expectativa que se desea
o requiere satisfacer. Esto es lo que el com√∫n de la gente denomina erradamente
problema, confundiendo los s√≠ntomas con las causas y con el verdadero problema.
Desde el punto de vista de quien tiene la necesidad o el deseo, esta fase se podr√≠a
denominar acertadamente **‚Äúsituaci√≥n problem√°tica‚Äù.**<br>

2. Un **estado final**, superior **‚ÄúB‚Äù**, el cual corresponde a la soluci√≥n del problema, a la
satisfacci√≥n de la necesidad o al valor agregado esperado. Alcanzar esta meta es el
objetivo principal de la disciplina de la ingenier√≠a en sus diferentes ramas, es decir, es
el ‚Äùque hacer‚Äù del ingeniero. El valor agregado de todos los proyectos y dise√±os de
ingenier√≠a se mide por el grado y la calidad alcanzados del estado *‚ÄùB‚Äù*.<br>

3. El proyecto, etapa que corresponde a las **estrategias** empleadas para darle soluci√≥n al
problema o para satisfacer la necesidad o el deseo planteado en la primera etapa. Es en
esta fase del problema donde el profesional aplica los conocimientos, habilidades y
destrezas adquiridas durante sus estudios profesionales, es decir, sus competencias en
el campo o problem√°tica respectiva.<br>

ejemplificaci√≥n de los estados A y B de un problema:

| ESTADO A | ESTRATEGIA | ESTADO B |
|-----------|-----------|-----------|
| Estudiante de Tec. Universitaria en Desarrollo Integral de Videojuegos  |‚üπ| T√©cnico/a Universitario/a en Dise√±o Integral de Videojuegos  |
| √Årbol  |‚üπ| Papel |
| Construcci√≥n Proyectada |‚üπ| Edificio terminado |
| Idea de videojuego  |‚üπ| Videojuego construido  |

### **‚¨õ Problema y Soluci√≥n desde una visi√≥n de ‚ÄúCaja Negra‚Äù** 
<br>

![image](https://github.com/AlexUnju/apuntes_fpoo/assets/142057928/2c615719-7ba4-4fa4-97e9-4ca3c173e74e)

##  VIDEO YOUTUBE PROBLEMA Y SOLUCION <img src="https://i.ibb.co/0Y8QBHD/yt.png" alt="yt" border="0" height="20"> <br>

[![Texto alternativo](https://img.youtube.com/vi/ickYKg0MyCk/maxresdefault.jpg)](https://www.youtube.com/watch?v=ickYKg0MyCk)

## **<img src="https://cdn-icons-png.flaticon.com/512/1448/1448776.png" height="25" align="left">PROGRAMACI√ìN**

Cuando la **estrategia** adoptada para obtener el estado deseado implica que los procesos sean
realizados por un ordenador; o dicho de otra manera cuando los sistemas utilizan procesos que
son llevados a cabo por un ordenador, entonces impl√≠citamente estos **sistemas recurrieron a la
programaci√≥n**.

### **üìö CONCEPTO DE PROGRAMACI√ìN**

El concepto de programaci√≥n abarca diferentes perspectivas en Ingenier√≠a del Software. Desde **la codificaci√≥n y documentaci√≥n de programas en lenguajes espec√≠ficos** hasta **el arte de traducir deseos humanos en instrucciones comprensibles para las computadoras**. Es un proceso creativo que implica **_limpiar, codificar, trazar y proteger el c√≥digo fuente_**. En esta materia, se destaca que **la programaci√≥n es tanto una disciplina como un arte** para crear software, donde un programador requiere habilidades esenciales para garantizar **la calidad del producto final, medida en t√©rminos de escalabilidad, reutilizaci√≥n y facilidad de mantenimiento.**

![image](https://github.com/AlexUnju/apuntes_fpoo/assets/142057928/64215b0e-66ed-4453-b5a0-9dbb16c04880)

### **üìï CONCEPTOS DERIVADOS DE LA PROGRAMACI√ìN**

**_Un programa de software es un conjunto de sentencias o instrucciones (algoritmos) escritos en
un lenguaje de programaci√≥n._**  <br>

Los programas forman parte de un conjunto m√°s grande
denominado **producto software**, el cual incluye los programas, **la documentaci√≥n de los
programas, la documentaci√≥n de an√°lisis y dise√±o de los programas, el manual de usuario, etc.**

En el desarrollo de un videojuego, el producto software incluye el c√≥digo fuente, el ejecutable, los instaladores, el manual, el documento de dise√±o (GDD), listas de assets y sonidos, concept art y la historia del juego.

En t√©rminos generales, un lenguaje de programaci√≥n es una herramienta que permite desarrollar programas para computadoras. Est√° compuesto por s√≠mbolos y reglas de sintaxis y sem√°ntica que definen su estructura y significado. El programador debe entender estas caracter√≠sticas para escribir algoritmos. Su funci√≥n principal es proporcionar un entorno para que los programadores creen programas que faciliten la comunicaci√≥n entre el usuario y la m√°quina.

Son muchos los tipos de lenguaje con los que un programador puede trabajar, pero nosotros
nos centraremos en dos: **Los lenguajes de bajo nivel y los lenguajes de alto nivel**.
#### ‚¨áÔ∏è Lenguaje de bajo nivel

El **lenguaje de bajo nivel** presenta ventajas como su sencillez, instrucciones directas y alta velocidad de ejecuci√≥n. Sin embargo, est√° estrechamente ligado al hardware, lo que puede dificultar la estructuraci√≥n de ciertos programas. Adem√°s, se requiere atenci√≥n especial para evitar errores que puedan aumentar la carga de trabajo y revisi√≥n del c√≥digo.
#### ‚¨ÜÔ∏è Lenguaje de alto nivel
Cuando hablamos de **lenguajes de alto nivel**, nos referimos a aquellos que se centran en las capacidades cognitivas humanas en lugar de en las capacidades de las m√°quinas. Estos lenguajes permiten a los programadores resolver problemas de manera sencilla y r√°pida, ofreciendo m√°xima flexibilidad y abstracci√≥n. Aunque generan un c√≥digo m√°s comprensible y v√°lido para diversas plataformas, pueden ralentizar el procesamiento ya que la computadora necesita m√°s tiempo para traducir las instrucciones. Adem√°s, algunos est√°n limitados a ciertas plataformas. En general, para los productos de software que se desarrollar√°n, los algoritmos se escribir√°n en un lenguaje de alto nivel.

##  VIDEO YOUTUBE PROGRAMACI√ìN <img src="https://i.ibb.co/0Y8QBHD/yt.png" alt="yt" border="0" height="20"> <br>
[![Texto alternativo](https://img.youtube.com/vi/IUTNblDwOfE/maxresdefault.jpg)](https://www.youtube.com/watch?v=IUTNblDwOfE)

### üìë FASES EN RESOLUCION DE PROBLEMAS MEDIANTE ALGORITMOS

El proceso de resoluci√≥n de problemas con una computadora implica escribir y ejecutar un programa. Aunque es un proceso creativo, sigue una serie de fases comunes que deben seguir la mayor√≠a de los programadores.

### üìñ FASES EN LA RESOLUCI√ìN DE PROBLEMAS CON COMPUTADORA
Las fases de resoluci√≥n de un problema con computadora son:
- An√°lisis del problema.
- Dise√±o del algoritmo.
- Codificaci√≥n.
- Compilaci√≥n y ejecuci√≥n.
- Verificaci√≥n.
- Depuraci√≥n.
- Mantenimiento.
- Documentaci√≥n.

  **Las caracter√≠sticas principales de la resoluci√≥n de problemas son:**

1. **An√°lisis:** Se estudia el problema considerando los requisitos especificados por el cliente o la persona encargada del programa.
2. **Dise√±o:** Se elabora una soluci√≥n que conduzca a un algoritmo para resolver el problema.
3. **Codificaci√≥n (Implementaci√≥n):** La soluci√≥n se traduce a la sintaxis de un lenguaje de alto nivel (como Java, C#, Processing, etc.) para crear archivos de c√≥digo fuente, que luego se traducen al lenguaje de la computadora.
4. **Ejecuci√≥n, Verificaci√≥n y Depuraci√≥n:** El programa se ejecuta, se verifica rigurosamente y se corrigen los errores ("bugs") que puedan surgir.
6. **Mantenimiento:** El programa se actualiza y modifica seg√∫n las necesidades de los usuarios.
7. **Documentaci√≥n:** Se documentan las diferentes fases del ciclo de vida del software, incluyendo an√°lisis, dise√±o, codificaci√≥n, as√≠ como manuales de usuario y de referencia, y normas para el mantenimiento.
Las dos primeras fases llevan al dise√±o detallado en forma de algoritmo. Durante la tercera fase (codificaci√≥n), se implementa este algoritmo en c√≥digo. La compilaci√≥n y ejecuci√≥n traducen y ejecutan el programa. En las fases de verificaci√≥n y depuraci√≥n, se buscan y corrigen errores. Es fundamental invertir tiempo en an√°lisis y dise√±o para reducir la necesidad de depuraci√≥n. Por √∫ltimo, se documenta el programa.

### ‚úçÔ∏è ALGORITMO Y METODOLOG√çA DE LA PROGRAMACI√ìN

Un algoritmo es un m√©todo para resolver un problema mediante una serie de pasos precisos,
definidos y finitos. Estas √∫ltimas tres palabras, son adem√°s las caracter√≠sticas de un algoritmo:
- **Preciso:** Indica el orden de realizaci√≥n de cada paso.
- **Definido:** Si se sigue dos veces, obtiene el mismo resultado cada vez.
- **Finito:** Tiene fin, un determinado n√∫mero de pasos.Debe producir un resultado en un tiempo finito.

Los m√©todos que utilizan algoritmos se llaman m√©todos algor√≠tmicos, mientras que los m√©todos que implican juicio se denominan m√©todos heur√≠sticos.
El eje central de esta metodolog√≠a es el concepto de algoritmo.
![image](https://github.com/AlexUnju/apuntes_fpoo/assets/142057928/7d08362e-a0b7-4243-8c11-8627cdece737)


Se consideran todos los elementos de un problema representado como un sistema inform√°tico:

1. Los datos de entrada (la situaci√≥n problem√°tica) y los datos de salida (la soluci√≥n) son esenciales para dise√±ar un algoritmo.

2. El dise√±o de un algoritmo implica una secuencia ordenada de pasos sin ambig√ºedades que conducen al desarrollo del proceso o estrategia. Esto incluye tanto la fase de an√°lisis del problema como la fase de dise√±o del algoritmo, donde se crea un modelo del programa que a√∫n no ha sido codificado.

3. A partir del dise√±o del algoritmo, se construye el programa en la fase de codificaci√≥n o implementaci√≥n.

4. El programa, junto con la configuraci√≥n del hardware y los documentos de desarrollo, constituyen el software del sistema inform√°tico. En este paso, el sistema puede ejecutarse, verificarse y depurarse, lo que corresponde a la fase de ejecuci√≥n de la resoluci√≥n de problemas mediante algoritmos.


|   |
|---|
| Entonces, la idea central de la Metodolog√≠a de la Programaci√≥n es que para llegar a la realizaci√≥n de un programa es necesario el dise√±o previo de un algoritmo, de modo que sin algoritmo no puede existir un programa. |

Los algoritmos son independientes del lenguaje de programaci√≥n y la computadora. Pueden expresarse en diferentes lenguajes y ejecutarse en diferentes m√°quinas manteniendo su esencia. En la ciencia de la computaci√≥n, los algoritmos son m√°s importantes que los lenguajes de programaci√≥n o las computadoras. Un lenguaje de programaci√≥n es solo un medio para expresar un algoritmo, y una computadora es simplemente un procesador para ejecutarlo.

### üß† AN√ÅLISIS DEL PROBLEMA

El an√°lisis del problema comprende dos etapas:

1. **Definici√≥n:** Se establece el prop√≥sito del algoritmo y se define claramente lo que se desea resolver, junto con los objetivos de su soluci√≥n.

2. **An√°lisis:** Se identifican las caracter√≠sticas del problema en t√©rminos de entradas y salidas, y se investigan los procesos necesarios para resolverlo. Se selecciona el proceso m√°s adecuado si hay varias opciones disponibles, o se desarrolla uno si no existen procesos previos.

![image](https://github.com/AlexUnju/apuntes_fpoo/assets/142057928/f334e5fc-337c-497c-9817-e79a4f1811c9)

**Ejemplo:** Se solicita desarrollar una calculadora que permita sumar dos n√∫meros

**Definici√≥n del Problema:** Desarrollar una calculadora que permita sumar dos n√∫meros

**An√°lisis:**
- Datos de Entrada: Dos n√∫meros, a los cuales denominaremos n√∫mero A y n√∫mero B
- Proceso:
-  - - ¬øQui√©n debe realizar el proceso?: Una calculadora
-  - - Cu√°l es el proceso que realiza la calculadora?
              
Donde lo que se ha aplicado es una ecuaci√≥n matem√°tica que la calculadora
puede realizar. La variable dependiente suma almacena el resultado de sumar
al n√∫mero A, el n√∫mero B.
- - - Datos de Salida: suma

### **üìè Consideraciones previas a la representaci√≥n de un algoritmo**

**Una variable** es un contenedor para almacenar informaci√≥n, compuesto por un identificador √∫nico y un tipo de datos que determina el rango de valores y operaciones aplicables. Los tipos de datos m√°s comunes incluyen **Entero, Real o Flotante, Car√°cter, Cadena de caracteres o string, y Fecha.** 

**La nomenclatura** del identificador sigue ciertas reglas comunes, como la unicidad y claridad del nombre, evitando el inicio con n√∫meros y utilizando may√∫sculas para separar palabras en nombres compuestos. Se sugiere evitar nombres excesivamente largos para facilitar la legibilidad. 

Adem√°s, se establecen convenciones para nombres espec√≠ficos, como **i, j, k para √≠ndices enteros**, **a, b, c para valores num√©ricos reales**, las variables llamadas **p y q se emplean para
apuntadores**; las variables llamadas **n y m son variables que contienen valores de tama√±os de matrices.**
Los nombres de variables se escriben en min√∫sculas para facilitar la lectura.

### üé® DISE√ëO DEL ALGORITMO
![image](https://github.com/AlexUnju/apuntes_fpoo/assets/142057928/7e83a87e-c4a6-466d-8c50-cc146e507da1)

#### CONCLUSI√ìN

El dise√±o de algoritmos es crucial en la ciencia de la computaci√≥n y se enfatiza en esta materia. Requiere creatividad y conocimiento t√©cnico. Los algoritmos pueden representarse de diversas formas. Se recomienda tomarse tiempo para analizar y dise√±ar antes de codificar, lo que evita problemas en la implementaci√≥n.

##  VIDEO FASES EN RESOLUCI√ìN DE UN ALGORITMO <img src="https://i.ibb.co/0Y8QBHD/yt.png" alt="yt" border="0" height="20"><br>

[![Texto alternativo](https://i.ytimg.com/vi/zXHAjyVmYEE/hqdefault.jpg?sqp=-oaymwE2CNACELwBSFXyq4qpAygIARUAAIhCGAFwAcABBvABAfgB_gmAAtAFigIMCAAQARhLIGUoOjAP&rs=AOn4CLCF5C2YNiaAYsIp4KSbog7pP8BWnA/maxresdefault.jpg)](https://www.youtube.com/watch?v=zXHAjyVmYEE)
#
# üîµ SEMANA 02
##
### üßÆ EXPRESI√ìN ARITM√âTICA
Las expresiones son combinaciones de constantes, variables, operadores y par√©ntesis. En algoritmos, las expresiones algebraicas se traducen a expresiones aritm√©ticas. Los operandos son las variables o constantes involucradas, mientras que los operadores realizan las operaciones entre ellos. El resultado de una expresi√≥n aritm√©tica es num√©rico, ya sea entero o real, y el punto se usa como separador decimal . Por ejemplo, suponga que ùëè = 4.5


### üìö OPERADORES ARITM√âTICOS

| Operador          | Descripci√≥n                      |
|-------------------|----------------------------------|
| +                 | Suma                             |
| -                 | Resta                            |
| *                 | Multiplicaci√≥n                   |
| /                 | Divisi√≥n                         |
| ** o ^            | Potenciaci√≥n                     |
| div               | Divisi√≥n entera                  |
| mod, %            | M√≥dulo (resto)                   |

Ejemplo:

| Operaci√≥n Matem√°tica | Expresi√≥n Aritm√©tica | Resultado |
|----------------------|----------------------|-----------|
| 5 + 3                | 5 + 3                | 8         |
| 10 - 4               | 10 - 4               | 6         |
| 2 x 6                | 2 * 6                | 12        |
| $\frac{15}{3}$       | 15 / 3               | 5         |
| $2^{3}$              | 2 ** 3               | 8         |
| 13 √∑ 5               | 13 div 5             | 2         |
| 13 mod 5             | 13 mod 5             | 3         |

### ‚ûñ‚ûñ‚ûï‚ûï OPERADORES DE INCREMENTO Y DECREMENTO

Los operadores de incremento (++), que aumentan el valor de su operando en una unidad, y de decremento (--), que disminuyen el valor de su operando en una unidad, son comunes en muchos lenguajes de programaci√≥n. Se pueden utilizar como prefijo (antes de la variable) o como sufijo (despu√©s de la variable), lo que afecta al valor resultante de la variable. Si se utiliza como prefijo, el operador cambia el valor de la variable y devuelve este nuevo valor; si se usa como sufijo, el resultado de la expresi√≥n es el valor de la variable, y luego se modifica esta variable.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/0c442d26-135d-4b28-8b56-3876693a43d0)

### üìè REGLAS DE PRIORIDAD

Las reglas de prioridad en expresiones aritm√©ticas determinan el orden de las operaciones. Estas reglas son:

1. Se eval√∫an primero las operaciones encerradas entre par√©ntesis, priorizando las m√°s internas.
2. Las operaciones aritm√©ticas siguen un orden de prioridad: primero los par√©ntesis, luego los operadores unitarios (++ y --), seguidos de multiplicaci√≥n, divisi√≥n y m√≥dulo, y finalmente suma y resta.
3. En lenguajes que admiten la operaci√≥n de exponenciaci√≥n, esta tiene la mayor prioridad.
4. Si hay varios operadores de igual prioridad, se sigue la asociatividad de izquierda a derecha.

Estas reglas garantizan un orden consistente en las operaciones.

| Operador          | Descripci√≥n                      |
|-------------------|----------------------------------|
| +                 | Suma                             |
| -                 | Resta                            |
| *                 | Multiplicaci√≥n                   |
| /                 | Divisi√≥n                         |
| ** o ^            | Potenciaci√≥n                     |
| div               | Divisi√≥n entera                  |
| mod, %            | M√≥dulo (resto)                   |
| **++**            | **Incremento**                   |
| **--**            | **Decremento**                   | 

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/9b7b07c5-c938-45ee-bb23-62b33304c996)

### üìö BIFURCACI√ìN
Una bifurcaci√≥n es una interrupci√≥n en el flujo normal de ejecuci√≥n de un algoritmo, con lo cual
la linealidad de ejecuci√≥n se altera:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/a3f9ec2f-5f0a-4dda-a265-8f3480f31b12)

Las bifurcaciones pueden ser, seg√∫n el punto del algoritmo donde se aplique de dos tipos: hacia
adelante o hacia atr√°s 

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/cdd06818-2797-4d73-a26d-6715be928712)

### üìñ BIFURCACI√ìN CONDICIONAL Y LAS EXPRESIONES LOGICAS

Una bifurcaci√≥n condicional depende del cumplimiento de una condici√≥n espec√≠fica. En el esquema representado, la evaluaci√≥n de la condici√≥n se muestra dentro de un rombo. Si la condici√≥n se cumple, el flujo de ejecuci√≥n contin√∫a por la acci√≥n F2; de lo contrario, se ejecuta la acci√≥n F1. Despu√©s de ejecutar las acciones, el flujo de ejecuci√≥n contin√∫a normalmente, como indican las flechas que se unen en el c√≠rculo. La evaluaci√≥n de la condici√≥n devuelve un valor que indica si se cumple o no; por lo tanto, se necesita un tipo de datos capaz de almacenar estos valores, como VERDADERO o FALSO. 

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/2f974e7c-dc61-4269-89eb-7c6ae8c7267e)

### üìë EL TIPO DE DATOS BOOLEAN (O L√ìGICO)

El tipo de datos Boolean, tambi√©n conocido como l√≥gico, permite almacenar solo dos estados: verdadero o falso. Se define una variable de tipo Boolean de la siguiente manera: "variable: Boolean". Por ejemplo, una variable que indique si un jugador ha completado su misi√≥n en un juego se puede definir como "isMissionComplete: Boolean" o "haFinalizadoMision: Boolean". Este tipo de datos se utiliza com√∫nmente en ingl√©s para los identificadores debido a su brevedad y claridad. Para asignar el valor verdadero a una variable booleana, se utiliza "verdadero", mientras que para asignar falso se utiliza "falso". Por ejemplo, para asignar verdadero a la variable "isMissionComplete", se escribir√≠a "isMissionComplete ‚Üê verdadero"; y para asignar falso, se escribir√≠a "isMissionComplete ‚Üê falso".

### üßÆ LOS OPERADORES RELACIONALES

As√≠ como las expresiones aritm√©ticas utilizan operadores aritm√©ticos; las expresiones l√≥gicas utilizan operadores relaciones y l√≥gicos.

Los operadores relacionales permiten realizar comparaciones de valores de tipo num√©rico o
car√°cter. Los operadores de relaci√≥n sirven para expresar las condiciones en los algoritmos y el resultado de la operaci√≥n ser√° verdadero o falso.

| Operador | Significado       |
|----------|-------------------|
| <        | Menor que         |
| >        | Mayor que         |
| = o ==   | Igual que         |
| <=       | Menor o igual que |
| >=       | Mayor o igual que |
| <> o !=  | Distinto de       |

ejemplo:

| numA | numB | Expresi√≥n L√≥gica | Resultado           |
|------|------|------------------|---------------------|
| 5    | 3    | 5 < 3            | Falso        |
| 10   | 4    | 10 > 4           | Verdadero    |
| 3    | 3    | 3 == 3           | Verdadero     |
| 5    | 3    | 5 <= 3           | Falso      |
| 8    | 8    | 8 >= 8           | Verdadero    |
| 7    | 5    | 7 != 5           | Verdadero     |

### üß† LOS OPERADORES LOGICOS

Estos operadores generalmente se van a utilizan para realizar combinaciones de expresiones
l√≥gicas que usan operadores relacionales.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/b2909759-b2dd-4b25-a4f4-a3f302c86db2)

Estos operadores trabajan sobre un resultado booleano. Es decir, eval√∫an una variable booleana
o el resultado de una operaci√≥n l√≥gica basada en operadores relaciones y act√∫a en consecuencia
seg√∫n las denominadas tablas de verdad.

#### ! Operador L√≥gico NO

Al aplicar el operador no, lo que hace es negar (asignar el valor opuesto) de a. Por lo tanto, el
resultado de no a, ser√° falso.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/2a89462a-4cef-405e-9494-be942187b0ab)

#### && Operador L√≥gico Y (o conjunci√≥n)

El operador Y toma los valores que devuelven las expresiones l√≥gicas a y b; y eval√∫a el resultado
en conjunto. 
As√≠, si tanto a como b son verdaderas, el resultado en conjunto ser√° verdadero, caso contrario
devolver√° falso

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/9ca9620b-aa5b-43bf-bfb3-f3968d06564f)

#### || El Operador L√≥gico O (o disyunci√≥n)

El operador O toma los valores que devuelven las expresiones l√≥gicas a y b; y eval√∫a el resultado
en conjunto.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/f1dd6f48-aaa1-44b3-846b-82d947932092)
##

# üî¥ SEMANA 03
## Estructuras Selectivas

Las estructuras de control iterativas permiten repetir una o varias acciones un n√∫mero espec√≠fico de veces. Dentro de estas estructuras, el bloque de c√≥digo que se repite se conoce como bucle, y cada repetici√≥n se llama iteraci√≥n.

### üìö CONCEPTOS
- Estructura de control iterativa: es un tipo de estructura de control que permite repetir
una o varias acciones (instrucciones o sentencias) un determinado n√∫mero de veces.
- Bucle: se indica con este nombre a la secci√≥n de c√≥digo que se repite. Es decir, dentro
de una estructura de control iterativa hay un bucle, por el cual luego de ejecutar su
√∫ltima instrucci√≥n saltar√° a la primera de cumplirse cierta condici√≥n.
- Iteraci√≥n: Cada repetici√≥n de un bucle se conoce como iteraci√≥n.
- 
Al dise√±ar un bucle, es fundamental responder dos preguntas:
1. ¬øQu√© acciones se repiten?
2. ¬øCu√°ntas veces se deben repetir?

La primera pregunta determina si se necesita una estructura iterativa y qu√© acciones se repiten. La segunda pregunta implica asegurar que el n√∫mero de iteraciones sea finito para evitar bucles infinitos. Es crucial tener un mecanismo que garantice la finalizaci√≥n del bucle.

Por ejemplo, al calcular el factorial de 5 (5!), se realiza el producto de todos los n√∫meros enteros del 1 al 5. Aqu√≠, se ejecuta una operaci√≥n un n√∫mero finito de veces (5 veces) con una condici√≥n de parada clara.


### üìö ESTRUCTURA ITERATIVA MIENTRAS

La estructura iterativa mientras (en ingl√©s while) es aquella en la que el bucle se repite
mientras se cumple una determinada condici√≥n. Cuando se ejecuta la instrucci√≥n mientras,
la primera cosa que sucede es que se eval√∫a la condici√≥n (una expresi√≥n l√≥gica o booleana).
Si el resultado de la evaluaci√≥n devuelve falso, no se ejecutar√° el bucle continuando la ejecuci√≥n
del algoritmo fuera de la estructura mientras (se dice que salta hacia afuera del
fin_mientras). Si la expresi√≥n booleana retorna verdadero, entonces se ejecuta el bucle y
al llegar al final de este se proceder√° a evaluar nuevamente la expresi√≥n booleana.
Por lo tanto, las iteraciones se suceder√°n una tras otra mientras la expresi√≥n booleana
(condici√≥n) siga retornando el valor verdadero. A continuaci√≥n, se esquematiza la estructura de
control iterativa mientras

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/234aabc0-04f3-4df0-8751-0437cd17d846)

### üìë UNA VARIABLE CON OBJETIVO ESPEC√çFICO: EL CONTADOR

Una variable con un prop√≥sito espec√≠fico en estructuras de control iterativas es el contador. El contador se utiliza para rastrear el n√∫mero de iteraciones en un bucle. Su funci√≥n principal es mantener un registro del progreso del bucle, aumentando o disminuyendo su valor en cada iteraci√≥n. Esto permite controlar el n√∫mero de repeticiones y determinar cu√°ndo detener el bucle. El contador es esencial para estructuras como los bucles for y while, donde su valor se actualiza en cada ciclo hasta que se alcanza una condici√≥n de salida espec√≠fica.

### üìö ESTRUCTURA ITERATIVA HACER-MIENTRAS

El bucle mientras eval√∫a la expresi√≥n al comienzo del bucle de repetici√≥n; siempre se utilizan
para crear bucle pre-test. Los bucles pre-test se denominan tambi√©n bucles controlados por la
entrada. En numerosas ocasiones se necesita que el conjunto de sentencias que componen el
cuerpo del bucle se ejecute al menos una vez sea cual sea el valor de la expresi√≥n o condici√≥n
de evaluaci√≥n. 

Estos bucles se denominan bucles post-test o bucles controlados por la salida. Un caso t√≠pico es
el bucle hacer-mientras (do-while).

El bucle hacer-mientras es an√°logo al bucle mientras y el cuerpo del bucle se ejecuta
una y otra vez mientras la condici√≥n (expresi√≥n booleana) sea verdadera. Existe, sin embargo,
una gran diferencia y es que el cuerpo del bucle est√° encerrado entre las palabras reservadas
hacer y mientras, de modo que las sentencias de dicho cuerpo se ejecutan, al menos una
vez, antes de que se eval√∫e la expresi√≥n booleana. En otras palabras, el cuerpo del bucle siempre
se ejecuta, al menos una vez, incluso aunque la expresi√≥n booleana sea falsa.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/31d19624-1db7-4183-b9d7-fab7777497bf)

### üìö ESTRUCTURA ITERATIVA PARA

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/1e79b484-2901-4e93-b6ec-08b16eb26f78)

La estructura del bucle for comienza con un valor inicial (vi) de la variable de √≠ndice (v), y las acciones especificadas se ejecutan mientras el valor inicial sea menor o igual al valor final (vf).
La variable de √≠ndice (vi) se incrementa en uno por defecto, o por un valor mayor seg√∫n lo indicado por incr. Si este nuevo valor no excede el valor final (vf), las acciones se ejecutan nuevamente.
Por lo tanto, las acciones dentro del bucle se repiten para cada valor de la variable de √≠ndice desde el valor inicial hasta el valor final, con el incremento indicado en incr.
El incremento de la variable de √≠ndice suele ser 1 por defecto, pero puede ser diferente, positivo o negativo, seg√∫n lo especificado.
Normalmente, la variable de √≠ndice es de tipo entero y se suelen usar letras como i, j, k como nombres.
El formato de la estructura del bucle for var√≠a si se desea un incremento distinto a 1, ya sea positivo o negativo (decremento).

## ‚å®Ô∏è PROGRAMACI√ìN CON PROCESSING

### üì¶ VARIABLES

Las variables son elementos fundamentales en la computaci√≥n y en la programaci√≥n. Permiten almacenar valores durante la ejecuci√≥n de un programa y pueden modificarse seg√∫n sea necesario. Cada variable est√° asociada a un espacio f√≠sico en la memoria del ordenador, tiene un nombre √∫nico llamado identificador, y puede contener diferentes tipos de datos, como n√∫meros, texto, o valores l√≥gicos.
El identificador de la variable, elegido por el programador, debe ser descriptivo y no puede coincidir con palabras reservadas del lenguaje de programaci√≥n. Por otro lado, el valor almacenado en la variable debe ser definido previamente, es decir, se debe especificar qu√© tipo de dato contendr√° la variable, como n√∫meros enteros, decimales, texto, o valores l√≥gicos.

### üìö TIPOS DE DATOS EN PROCESSING

Processing ofrece varios tipos de datos para almacenar diferentes tipos de informaci√≥n. Estos se dividen en dos categor√≠as principales: primitivos y tipos de referencia. En este momento, nos centraremos en los primitivos.

1. **int**: Representa enteros de 32 bits con un rango desde -2.147.483.648 hasta 2.147.483.647.
2. **float**: Almacena n√∫meros con punto decimal, con un rango desde aproximadamente -3.4 √ó 10^38 hasta 3.4 √ó 10^38.
3. **char**: Permite almacenar caracteres individuales, como letras o s√≠mbolos, en el formato Unicode.
4. **boolean**: Solo puede almacenar dos valores: `TRUE` o `FALSE`, √∫til para controlar el flujo de los programas.
5. **color**: Permite almacenar colores codificados en n√∫meros hexadecimales.

Estos tipos de datos son fundamentales para definir variables y realizar operaciones en programas de Processing. Cada tipo tiene un rango de valores espec√≠fico y se utiliza seg√∫n las necesidades del programa.


### üìñ LAS VARIABLES PREDEFINIDAS (O DEL SISTEMA)

Processing proporciona varias variables predefinidas que pueden ser utilizadas directamente en los programas sin necesidad de declararlas. Estas variables son √∫tiles para obtener informaci√≥n sobre la ventana de trabajo, la interacci√≥n del usuario y otros aspectos del entorno de ejecuci√≥n. Algunas de las variables predefinidas m√°s importantes son:

1. `width`: Almacena el ancho de la ventana de trabajo.
2. `height`: Almacena el alto de la ventana de trabajo.
3. `frameRate`: Guarda la velocidad de ejecuci√≥n del programa.
4. `frameCount`: Contiene el n√∫mero de frames ejecutados desde el inicio del programa.
5. `displayHeight`: Almacena el alto de la pantalla completa.
6. `displayWidth`: Almacena el ancho de la pantalla completa.
7. `key`: Contiene el valor de la tecla recientemente oprimida.
8. `keyCode`: Detecta teclas especiales como flechas o teclas modificadoras.
9. `keyPressed`: Es verdadero si alguna tecla est√° siendo oprimida.
10. `mouseX`: La coordenada horizontal del mouse dentro de la ventana de trabajo.
11. `mouseY`: La coordenada vertical del mouse dentro de la ventana de trabajo.
12. `pmouseX`: La posici√≥n horizontal del mouse en el frame anterior.
13. `pmouseY`: La posici√≥n vertical del mouse en el frame anterior.
14. `mousePressed`: Indica si el bot√≥n del mouse est√° siendo oprimido.
15. `mouseButton`: Detecta qu√© bot√≥n del mouse fue seleccionado.
Estas variables simplifican el desarrollo de programas en Processing al proporcionar informaci√≥n relevante sobre la interacci√≥n del usuario y el entorno de ejecuci√≥n.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/9663e264-976d-4168-97e4-0ba2a9ec934f)


### üìö LAS ESTRUCTURAS DE CONTROL CONDICIONALES

En Processing, las estructuras de control condicionales son herramientas fundamentales para dirigir el flujo de ejecuci√≥n de un programa basado en condiciones espec√≠ficas. Estas estructuras incluyen:

1. **Estructuras Condicionales Simples:**
   - Permiten tomar decisiones basadas en una √∫nica comparaci√≥n.
   - Se utilizan para ejecutar un bloque de c√≥digo si una condici√≥n es verdadera.
   - La sintaxis b√°sica es:
     ```java
     if (condicion) {
         // Bloque de c√≥digo a ejecutar si la condici√≥n es verdadera
     }
     ```

2. **Estructuras Condicionales Dobles:**
   - Permiten elegir entre dos opciones basadas en el cumplimiento de una condici√≥n.
   - Se ejecuta un bloque de c√≥digo si la condici√≥n es verdadera y otro si es falsa.
   - La sintaxis b√°sica es:
     ```java
     if (condicion) {
         // Bloque de c√≥digo a ejecutar si la condici√≥n es verdadera
     } else {
         // Bloque de c√≥digo a ejecutar si la condici√≥n es falsa
     }
     ```

3. **Estructuras Condicionales M√∫ltiples Anidadas:**
   - Permiten evaluar una expresi√≥n contra m√∫ltiples resultados posibles.
   - Se utilizan m√∫ltiples `else if` despu√©s de un `if` para evaluar varias condiciones.
   - La estructura es:
     ```java
     if (condicion1) {
         // Bloque de c√≥digo a ejecutar si la condici√≥n1 es verdadera
     } else if (condicion2) {
         // Bloque de c√≥digo a ejecutar si la condicion2 es verdadera
     } else {
         // Bloque de c√≥digo a ejecutar si ninguna de las condiciones anteriores es verdadera
     }
     ```

Adem√°s, en Processing se utilizan operadores l√≥gicos como `&&` (AND) y `||` (OR) para realizar evaluaciones l√≥gicas combinadas.

### || && ! LOS OPERADORES L√ìGICOS

Los operadores l√≥gicos permiten hacer una evaluaci√≥n unificada, dado un conjunto de
expresiones l√≥gicas. Los operadores l√≥gicos que ofrece Processing son:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/663e1579-896f-422e-9055-ac9864294e3a)

- El &&: La conjunci√≥n es un operador que opera sobre dos valores de verdad.
T√≠picamente los valores de verdad de dos condiciones, devolviendo el valor de verdad
verdadero cuando ambas proposiciones son verdaderas, y falso en cualquier otro caso.
Es decir que es verdadera cuando ambas son verdaderas. La tabla de verdad de la
conjunci√≥n es la siguiente:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/bbfdcb3d-4eb9-4fbf-a830-31764724ddcb)

- El ||: La disyunci√≥n es un operador que funciona sobre dos valores de verdad,
t√≠picamente los valores de verdad de dos condiciones, devolviendo el valor de verdadero
cuando una de las proposiciones es verdadera, o cuando ambas lo son, y falso cuando
ambas son falsas.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/3385b998-d52b-470e-889b-049526b5a881)

### üìñ FUNCI√ìN RANDOM

La funci√≥n random() se refiere al proceso de aleatoriedad. Este t√©rmino se asocia a todo proceso
cuyo resultado no es previsible m√°s que por azar. El resultado de todo suceso aleatorio no puede
determinarse en ning√∫n caso antes de que este se produzca. En computaci√≥n, la funci√≥n
random() es capaz de generar un n√∫mero flotante aleatorio dado un rango de valores
proporcionado. 

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/9ca3a43a-d808-4c5f-98ec-4f71cbec2279)

### üîÅ ESTRUCTURA DE CONTROL ITERATIVAS

En cuanto a las estructuras de control iterativas, existen dos principales en Processing:

1. **La Instrucci√≥n `while`:**
   - Permite repetir un bloque de c√≥digo mientras se cumpla una condici√≥n.
   - La estructura b√°sica es:
     ```java
     while (condicion) {
         // Bloque de c√≥digo a repetir mientras la condici√≥n sea verdadera
     }
     ```

2. **La Instrucci√≥n `for`:**
   - Se utiliza cuando se conoce de antemano el n√∫mero de veces que se debe repetir un bloque de c√≥digo.
   - La estructura b√°sica es:
     ```java
     for (inicializaci√≥n; condici√≥n; actualizaci√≥n) {
         // Bloque de c√≥digo a ejecutar mientras se cumpla la condici√≥n
     }
     ```

Estas estructuras de control son esenciales para dirigir el flujo de ejecuci√≥n de un programa y tomar decisiones basadas en condiciones espec√≠ficas. Tambi√©n facilitan la repetici√≥n de bloques de c√≥digo, lo que permite una programaci√≥n m√°s eficiente y estructurada.



