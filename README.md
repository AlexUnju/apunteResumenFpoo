## Apuntes de Fundamentos de la Programaci√≥n Orientado a Objetos
###### _No olvides darle una estrellita a este repositorio :D  -_ <img src="https://i.ibb.co/0nX0bNR/Screenshot-2024-05-07-164050.png" alt="Screenshot-2024-05-07-164050" border="0" height="30em" align="center">
<img src="https://i.ibb.co/ryRMhP0/fpoo.png" alt="fpoo" border="0" height="370em"><br> 
##
# üü¢ SEMANA 01
### **üòµ‚Äçüí´ PROBLEMA Y SOLUCI√ìN**
<br>

| |
|---|
| **_"La programaci√≥n surge como respuesta a la necesidad de resolver problemas mediante la ejecuci√≥n de instrucciones por un ordenador"_**|

<br>

### **üìö CONCEPTO DE PROBLEMA**

Un problema en **t√©rminos generales** se puede conceptualizar de las siguientes maneras: 
- Es un asunto o cuesti√≥n que se debe solucionar o aclarar.
- Una contradicci√≥n o un conflicto entre lo que es y lo que debe ser.
- Una dificultad o un inconveniente para la consecuci√≥n de un fin.
- Un disgusto, una molestia o una preocupaci√≥n.
<br>

El  concepto de problema derivado de la Ingenier√≠a en su libro Introducci√≥n a la ingenier√≠a (1998) el autor **Krick afirma** que: <br>
| |
|---|
|**_‚ÄúUn problema proviene del deseo de lograr la transformaci√≥n de un estado en otro‚Äù_**| 
<br>

Ejemplo:
<br>
Si una persona est√° enferma **(Estado A)** , nace la necesidad o deseo de mejorar la salud; es decir
pasar a que esa persona est√© saludable **(Estado B)**, por medio de un tratamiento, operaci√≥n o
cualquier otra acci√≥n que produzca el cambio de estado. 
<br>
ejemplo 2:
<br>
Se necesita ense√±ar a ni√±os a cruzar la calle (**Estado A:** ni√±os no saben cruzar la calle) de una
manera entretenida y educativa (**Estado B:** los ni√±os aprendieron a cruzar la calle).

### **üß© PARTES DE UN PROBLEMA**
Todo problema est√° compuesto, conceptualmente, por tres partes o aspectos:
1. **Un estado inicial**, **‚ÄúA‚Äù** inferior, que se manifiesta por medio de s√≠ntomas, efectos o
consecuencias producto de una carencia, necesidad, deseo o expectativa que se desea
o requiere satisfacer. Esto es lo que el com√∫n de la gente denomina erradamente
problema, confundiendo los s√≠ntomas con las causas y con el verdadero problema.
Desde el punto de vista de quien tiene la necesidad o el deseo, esta fase se podr√≠a
denominar acertadamente **‚Äúsituaci√≥n problem√°tica‚Äù.**<br>

2. Un **estado final**, superior **‚ÄúB‚Äù**, el cual corresponde a la soluci√≥n del problema, a la
satisfacci√≥n de la necesidad o al valor agregado esperado. Alcanzar esta meta es el
objetivo principal de la disciplina de la ingenier√≠a en sus diferentes ramas, es decir, es
el ‚Äùque hacer‚Äù del ingeniero. El valor agregado de todos los proyectos y dise√±os de
ingenier√≠a se mide por el grado y la calidad alcanzados del estado *‚ÄùB‚Äù*.<br>

3. El proyecto, etapa que corresponde a las **estrategias** empleadas para darle soluci√≥n al
problema o para satisfacer la necesidad o el deseo planteado en la primera etapa. Es en
esta fase del problema donde el profesional aplica los conocimientos, habilidades y
destrezas adquiridas durante sus estudios profesionales, es decir, sus competencias en
el campo o problem√°tica respectiva.<br>

ejemplificaci√≥n de los estados A y B de un problema:

| ESTADO A | ESTRATEGIA | ESTADO B |
|-----------|-----------|-----------|
| Estudiante de Tec. Universitaria en Desarrollo Integral de Videojuegos  |‚üπ| T√©cnico/a Universitario/a en Dise√±o Integral de Videojuegos  |
| √Årbol  |‚üπ| Papel |
| Construcci√≥n Proyectada |‚üπ| Edificio terminado |
| Idea de videojuego  |‚üπ| Videojuego construido  |

### **‚¨õ Problema y Soluci√≥n desde una visi√≥n de ‚ÄúCaja Negra‚Äù** 
<br>

![image](https://github.com/AlexUnju/apuntes_fpoo/assets/142057928/2c615719-7ba4-4fa4-97e9-4ca3c173e74e)

##  VIDEO YOUTUBE PROBLEMA Y SOLUCION <img src="https://i.ibb.co/0Y8QBHD/yt.png" alt="yt" border="0" height="20"> <br>

[![Texto alternativo](https://img.youtube.com/vi/ickYKg0MyCk/maxresdefault.jpg)](https://www.youtube.com/watch?v=ickYKg0MyCk)

## **<img src="https://cdn-icons-png.flaticon.com/512/1448/1448776.png" height="25" align="left">PROGRAMACI√ìN**

Cuando la **estrategia** adoptada para obtener el estado deseado implica que los procesos sean
realizados por un ordenador; o dicho de otra manera cuando los sistemas utilizan procesos que
son llevados a cabo por un ordenador, entonces impl√≠citamente estos **sistemas recurrieron a la
programaci√≥n**.

### **üìö CONCEPTO DE PROGRAMACI√ìN**

El concepto de programaci√≥n abarca diferentes perspectivas en Ingenier√≠a del Software. Desde **la codificaci√≥n y documentaci√≥n de programas en lenguajes espec√≠ficos** hasta **el arte de traducir deseos humanos en instrucciones comprensibles para las computadoras**. Es un proceso creativo que implica **_limpiar, codificar, trazar y proteger el c√≥digo fuente_**. En esta materia, se destaca que **la programaci√≥n es tanto una disciplina como un arte** para crear software, donde un programador requiere habilidades esenciales para garantizar **la calidad del producto final, medida en t√©rminos de escalabilidad, reutilizaci√≥n y facilidad de mantenimiento.**

![image](https://github.com/AlexUnju/apuntes_fpoo/assets/142057928/64215b0e-66ed-4453-b5a0-9dbb16c04880)

### **üìï CONCEPTOS DERIVADOS DE LA PROGRAMACI√ìN**

**_Un programa de software es un conjunto de sentencias o instrucciones (algoritmos) escritos en
un lenguaje de programaci√≥n._**  <br>

Los programas forman parte de un conjunto m√°s grande
denominado **producto software**, el cual incluye los programas, **la documentaci√≥n de los
programas, la documentaci√≥n de an√°lisis y dise√±o de los programas, el manual de usuario, etc.**

En el desarrollo de un videojuego, el producto software incluye el c√≥digo fuente, el ejecutable, los instaladores, el manual, el documento de dise√±o (GDD), listas de assets y sonidos, concept art y la historia del juego.

En t√©rminos generales, un lenguaje de programaci√≥n es una herramienta que permite desarrollar programas para computadoras. Est√° compuesto por s√≠mbolos y reglas de sintaxis y sem√°ntica que definen su estructura y significado. El programador debe entender estas caracter√≠sticas para escribir algoritmos. Su funci√≥n principal es proporcionar un entorno para que los programadores creen programas que faciliten la comunicaci√≥n entre el usuario y la m√°quina.

Son muchos los tipos de lenguaje con los que un programador puede trabajar, pero nosotros
nos centraremos en dos: **Los lenguajes de bajo nivel y los lenguajes de alto nivel**.
#### ‚¨áÔ∏è Lenguaje de bajo nivel

El **lenguaje de bajo nivel** presenta ventajas como su sencillez, instrucciones directas y alta velocidad de ejecuci√≥n. Sin embargo, est√° estrechamente ligado al hardware, lo que puede dificultar la estructuraci√≥n de ciertos programas. Adem√°s, se requiere atenci√≥n especial para evitar errores que puedan aumentar la carga de trabajo y revisi√≥n del c√≥digo.
#### ‚¨ÜÔ∏è Lenguaje de alto nivel
Cuando hablamos de **lenguajes de alto nivel**, nos referimos a aquellos que se centran en las capacidades cognitivas humanas en lugar de en las capacidades de las m√°quinas. Estos lenguajes permiten a los programadores resolver problemas de manera sencilla y r√°pida, ofreciendo m√°xima flexibilidad y abstracci√≥n. Aunque generan un c√≥digo m√°s comprensible y v√°lido para diversas plataformas, pueden ralentizar el procesamiento ya que la computadora necesita m√°s tiempo para traducir las instrucciones. Adem√°s, algunos est√°n limitados a ciertas plataformas. En general, para los productos de software que se desarrollar√°n, los algoritmos se escribir√°n en un lenguaje de alto nivel.

##  VIDEO YOUTUBE PROGRAMACI√ìN <img src="https://i.ibb.co/0Y8QBHD/yt.png" alt="yt" border="0" height="20"> <br>
[![Texto alternativo](https://img.youtube.com/vi/IUTNblDwOfE/maxresdefault.jpg)](https://www.youtube.com/watch?v=IUTNblDwOfE)
 
### üìë FASES EN RESOLUCION DE PROBLEMAS MEDIANTE ALGORITMOS

El proceso de resoluci√≥n de problemas con una computadora implica escribir y ejecutar un programa. Aunque es un proceso creativo, sigue una serie de fases comunes que deben seguir la mayor√≠a de los programadores.

### üìñ FASES EN LA RESOLUCI√ìN DE PROBLEMAS CON COMPUTADORA
Las fases de resoluci√≥n de un problema con computadora son:
- An√°lisis del problema.
- Dise√±o del algoritmo.
- Codificaci√≥n.
- Compilaci√≥n y ejecuci√≥n.
- Verificaci√≥n.
- Depuraci√≥n.
- Mantenimiento.
- Documentaci√≥n.

  **Las caracter√≠sticas principales de la resoluci√≥n de problemas son:**

1. **An√°lisis:** Se estudia el problema considerando los requisitos especificados por el cliente o la persona encargada del programa.
2. **Dise√±o:** Se elabora una soluci√≥n que conduzca a un algoritmo para resolver el problema.
3. **Codificaci√≥n (Implementaci√≥n):** La soluci√≥n se traduce a la sintaxis de un lenguaje de alto nivel (como Java, C#, Processing, etc.) para crear archivos de c√≥digo fuente, que luego se traducen al lenguaje de la computadora.
4. **Ejecuci√≥n, Verificaci√≥n y Depuraci√≥n:** El programa se ejecuta, se verifica rigurosamente y se corrigen los errores ("bugs") que puedan surgir.
6. **Mantenimiento:** El programa se actualiza y modifica seg√∫n las necesidades de los usuarios.
7. **Documentaci√≥n:** Se documentan las diferentes fases del ciclo de vida del software, incluyendo an√°lisis, dise√±o, codificaci√≥n, as√≠ como manuales de usuario y de referencia, y normas para el mantenimiento.
Las dos primeras fases llevan al dise√±o detallado en forma de algoritmo. Durante la tercera fase (codificaci√≥n), se implementa este algoritmo en c√≥digo. La compilaci√≥n y ejecuci√≥n traducen y ejecutan el programa. En las fases de verificaci√≥n y depuraci√≥n, se buscan y corrigen errores. Es fundamental invertir tiempo en an√°lisis y dise√±o para reducir la necesidad de depuraci√≥n. Por √∫ltimo, se documenta el programa.

### ‚úçÔ∏è ALGORITMO Y METODOLOG√çA DE LA PROGRAMACI√ìN

Un algoritmo es un m√©todo para resolver un problema mediante una serie de pasos precisos,
definidos y finitos. Estas √∫ltimas tres palabras, son adem√°s las caracter√≠sticas de un algoritmo:
- **Preciso:** Indica el orden de realizaci√≥n de cada paso.
- **Definido:** Si se sigue dos veces, obtiene el mismo resultado cada vez.
- **Finito:** Tiene fin, un determinado n√∫mero de pasos.Debe producir un resultado en un tiempo finito.

Los m√©todos que utilizan algoritmos se llaman m√©todos algor√≠tmicos, mientras que los m√©todos que implican juicio se denominan m√©todos heur√≠sticos.
El eje central de esta metodolog√≠a es el concepto de algoritmo.
![image](https://github.com/AlexUnju/apuntes_fpoo/assets/142057928/7d08362e-a0b7-4243-8c11-8627cdece737)


Se consideran todos los elementos de un problema representado como un sistema inform√°tico:

1. Los datos de entrada (la situaci√≥n problem√°tica) y los datos de salida (la soluci√≥n) son esenciales para dise√±ar un algoritmo.

2. El dise√±o de un algoritmo implica una secuencia ordenada de pasos sin ambig√ºedades que conducen al desarrollo del proceso o estrategia. Esto incluye tanto la fase de an√°lisis del problema como la fase de dise√±o del algoritmo, donde se crea un modelo del programa que a√∫n no ha sido codificado.

3. A partir del dise√±o del algoritmo, se construye el programa en la fase de codificaci√≥n o implementaci√≥n.

4. El programa, junto con la configuraci√≥n del hardware y los documentos de desarrollo, constituyen el software del sistema inform√°tico. En este paso, el sistema puede ejecutarse, verificarse y depurarse, lo que corresponde a la fase de ejecuci√≥n de la resoluci√≥n de problemas mediante algoritmos.


|   |
|---|
| Entonces, la idea central de la Metodolog√≠a de la Programaci√≥n es que para llegar a la realizaci√≥n de un programa es necesario el dise√±o previo de un algoritmo, de modo que sin algoritmo no puede existir un programa. |

Los algoritmos son independientes del lenguaje de programaci√≥n y la computadora. Pueden expresarse en diferentes lenguajes y ejecutarse en diferentes m√°quinas manteniendo su esencia. En la ciencia de la computaci√≥n, los algoritmos son m√°s importantes que los lenguajes de programaci√≥n o las computadoras. Un lenguaje de programaci√≥n es solo un medio para expresar un algoritmo, y una computadora es simplemente un procesador para ejecutarlo.

### üß† AN√ÅLISIS DEL PROBLEMA

El an√°lisis del problema comprende dos etapas:

1. **Definici√≥n:** Se establece el prop√≥sito del algoritmo y se define claramente lo que se desea resolver, junto con los objetivos de su soluci√≥n.

2. **An√°lisis:** Se identifican las caracter√≠sticas del problema en t√©rminos de entradas y salidas, y se investigan los procesos necesarios para resolverlo. Se selecciona el proceso m√°s adecuado si hay varias opciones disponibles, o se desarrolla uno si no existen procesos previos.

![image](https://github.com/AlexUnju/apuntes_fpoo/assets/142057928/f334e5fc-337c-497c-9817-e79a4f1811c9)

**Ejemplo:** Se solicita desarrollar una calculadora que permita sumar dos n√∫meros

**Definici√≥n del Problema:** Desarrollar una calculadora que permita sumar dos n√∫meros

**An√°lisis:**
- Datos de Entrada: Dos n√∫meros, a los cuales denominaremos n√∫mero A y n√∫mero B
- Proceso:
-  - - ¬øQui√©n debe realizar el proceso?: Una calculadora
-  - - Cu√°l es el proceso que realiza la calculadora?
              
Donde lo que se ha aplicado es una ecuaci√≥n matem√°tica que la calculadora
puede realizar. La variable dependiente suma almacena el resultado de sumar
al n√∫mero A, el n√∫mero B.
- - - Datos de Salida: suma

### **üìè Consideraciones previas a la representaci√≥n de un algoritmo**

**Una variable** es un contenedor para almacenar informaci√≥n, compuesto por un identificador √∫nico y un tipo de datos que determina el rango de valores y operaciones aplicables. Los tipos de datos m√°s comunes incluyen **Entero, Real o Flotante, Car√°cter, Cadena de caracteres o string, y Fecha.** 

**La nomenclatura** del identificador sigue ciertas reglas comunes, como la unicidad y claridad del nombre, evitando el inicio con n√∫meros y utilizando may√∫sculas para separar palabras en nombres compuestos. Se sugiere evitar nombres excesivamente largos para facilitar la legibilidad. 

Adem√°s, se establecen convenciones para nombres espec√≠ficos, como **i, j, k para √≠ndices enteros**, **a, b, c para valores num√©ricos reales**, las variables llamadas **p y q se emplean para
apuntadores**; las variables llamadas **n y m son variables que contienen valores de tama√±os de matrices.**
Los nombres de variables se escriben en min√∫sculas para facilitar la lectura.

### üé® DISE√ëO DEL ALGORITMO
![image](https://github.com/AlexUnju/apuntes_fpoo/assets/142057928/7e83a87e-c4a6-466d-8c50-cc146e507da1)

#### CONCLUSI√ìN

El dise√±o de algoritmos es crucial en la ciencia de la computaci√≥n y se enfatiza en esta materia. Requiere creatividad y conocimiento t√©cnico. Los algoritmos pueden representarse de diversas formas. Se recomienda tomarse tiempo para analizar y dise√±ar antes de codificar, lo que evita problemas en la implementaci√≥n.

##  VIDEO FASES EN RESOLUCI√ìN DE UN ALGORITMO <img src="https://i.ibb.co/0Y8QBHD/yt.png" alt="yt" border="0" height="20"><br>

[![Texto alternativo](https://i.ytimg.com/vi/zXHAjyVmYEE/hqdefault.jpg?sqp=-oaymwE2CNACELwBSFXyq4qpAygIARUAAIhCGAFwAcABBvABAfgB_gmAAtAFigIMCAAQARhLIGUoOjAP&rs=AOn4CLCF5C2YNiaAYsIp4KSbog7pP8BWnA/maxresdefault.jpg)](https://www.youtube.com/watch?v=zXHAjyVmYEE)
#
# üîµ SEMANA 02
##
### üßÆ EXPRESI√ìN ARITM√âTICA
Las expresiones son combinaciones de constantes, variables, operadores y par√©ntesis. En algoritmos, las expresiones algebraicas se traducen a expresiones aritm√©ticas. Los operandos son las variables o constantes involucradas, mientras que los operadores realizan las operaciones entre ellos. El resultado de una expresi√≥n aritm√©tica es num√©rico, ya sea entero o real, y el punto se usa como separador decimal . Por ejemplo, suponga que ùëè = 4.5


### üìö OPERADORES ARITM√âTICOS

| Operador          | Descripci√≥n                      |
|-------------------|----------------------------------|
| +                 | Suma                             |
| -                 | Resta                            |
| *                 | Multiplicaci√≥n                   |
| /                 | Divisi√≥n                         |
| ** o ^            | Potenciaci√≥n                     |
| div               | Divisi√≥n entera                  |
| mod, %            | M√≥dulo (resto)                   |

Ejemplo:

| Operaci√≥n Matem√°tica | Expresi√≥n Aritm√©tica | Resultado |
|----------------------|----------------------|-----------|
| 5 + 3                | 5 + 3                | 8         |
| 10 - 4               | 10 - 4               | 6         |
| 2 x 6                | 2 * 6                | 12        |
| $\frac{15}{3}$       | 15 / 3               | 5         |
| $2^{3}$              | 2 ** 3               | 8         |
| 13 √∑ 5               | 13 div 5             | 2         |
| 13 mod 5             | 13 mod 5             | 3         |

### ‚ûñ‚ûñ‚ûï‚ûï OPERADORES DE INCREMENTO Y DECREMENTO

Los operadores de incremento (++), que aumentan el valor de su operando en una unidad, y de decremento (--), que disminuyen el valor de su operando en una unidad, son comunes en muchos lenguajes de programaci√≥n. Se pueden utilizar como prefijo (antes de la variable) o como sufijo (despu√©s de la variable), lo que afecta al valor resultante de la variable. Si se utiliza como prefijo, el operador cambia el valor de la variable y devuelve este nuevo valor; si se usa como sufijo, el resultado de la expresi√≥n es el valor de la variable, y luego se modifica esta variable.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/0c442d26-135d-4b28-8b56-3876693a43d0)

### üìè REGLAS DE PRIORIDAD

Las reglas de prioridad en expresiones aritm√©ticas determinan el orden de las operaciones. Estas reglas son:

1. Se eval√∫an primero las operaciones encerradas entre par√©ntesis, priorizando las m√°s internas.
2. Las operaciones aritm√©ticas siguen un orden de prioridad: primero los par√©ntesis, luego los operadores unitarios (++ y --), seguidos de multiplicaci√≥n, divisi√≥n y m√≥dulo, y finalmente suma y resta.
3. En lenguajes que admiten la operaci√≥n de exponenciaci√≥n, esta tiene la mayor prioridad.
4. Si hay varios operadores de igual prioridad, se sigue la asociatividad de izquierda a derecha.

Estas reglas garantizan un orden consistente en las operaciones.

| Operador          | Descripci√≥n                      |
|-------------------|----------------------------------|
| ()                | Parentesis                      |
| ++                | Incremento                      |
| --                | Decremento                      |
| *                 | Multiplicaci√≥n √≥ producto        |
| /                 | Divisi√≥n                         |
| %                 | M√≥dulo                           |
| +                 | Suma                             |
| -                 | Resta                            |

recordar el orden de prioridad son:
- ()
- ++, --
- *, /, %
- +, -

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/9b7b07c5-c938-45ee-bb23-62b33304c996)

### üìö BIFURCACI√ìN
Una bifurcaci√≥n es una interrupci√≥n en el flujo normal de ejecuci√≥n de un algoritmo, con lo cual
la linealidad de ejecuci√≥n se altera:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/a3f9ec2f-5f0a-4dda-a265-8f3480f31b12)

Las bifurcaciones pueden ser, seg√∫n el punto del algoritmo donde se aplique de dos tipos: hacia
adelante o hacia atr√°s 

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/cdd06818-2797-4d73-a26d-6715be928712)

### üìñ BIFURCACI√ìN CONDICIONAL Y LAS EXPRESIONES LOGICAS

Una bifurcaci√≥n condicional depende del cumplimiento de una condici√≥n espec√≠fica. En el esquema representado, la evaluaci√≥n de la condici√≥n se muestra dentro de un rombo. Si la condici√≥n se cumple, el flujo de ejecuci√≥n contin√∫a por la acci√≥n F2; de lo contrario, se ejecuta la acci√≥n F1. Despu√©s de ejecutar las acciones, el flujo de ejecuci√≥n contin√∫a normalmente, como indican las flechas que se unen en el c√≠rculo. La evaluaci√≥n de la condici√≥n devuelve un valor que indica si se cumple o no; por lo tanto, se necesita un tipo de datos capaz de almacenar estos valores, como VERDADERO o FALSO. 

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/2f974e7c-dc61-4269-89eb-7c6ae8c7267e)

### üìë EL TIPO DE DATOS BOOLEAN (O L√ìGICO)

El tipo de datos Boolean, tambi√©n conocido como l√≥gico, permite almacenar solo dos estados: verdadero o falso. Se define una variable de tipo Boolean de la siguiente manera: "variable: Boolean". Por ejemplo, una variable que indique si un jugador ha completado su misi√≥n en un juego se puede definir como "isMissionComplete: Boolean" o "haFinalizadoMision: Boolean". Este tipo de datos se utiliza com√∫nmente en ingl√©s para los identificadores debido a su brevedad y claridad. Para asignar el valor verdadero a una variable booleana, se utiliza "verdadero", mientras que para asignar falso se utiliza "falso". Por ejemplo, para asignar verdadero a la variable "isMissionComplete", se escribir√≠a "isMissionComplete ‚Üê verdadero"; y para asignar falso, se escribir√≠a "isMissionComplete ‚Üê falso".

### üßÆ LOS OPERADORES RELACIONALES

As√≠ como las expresiones aritm√©ticas utilizan operadores aritm√©ticos; las expresiones l√≥gicas utilizan operadores relaciones y l√≥gicos.

Los operadores relacionales permiten realizar comparaciones de valores de tipo num√©rico o
car√°cter. Los operadores de relaci√≥n sirven para expresar las condiciones en los algoritmos y el resultado de la operaci√≥n ser√° verdadero o falso.

| Operador | Significado       |
|----------|-------------------|
| <        | Menor que         |
| >        | Mayor que         |
| = o ==   | Igual que         |
| <=       | Menor o igual que |
| >=       | Mayor o igual que |
| <> o !=  | Distinto de       |

ejemplo:

| numA | numB | Expresi√≥n L√≥gica | Resultado           |
|------|------|------------------|---------------------|
| 5    | 3    | 5 < 3            | Falso        |
| 10   | 4    | 10 > 4           | Verdadero    |
| 3    | 3    | 3 == 3           | Verdadero     |
| 5    | 3    | 5 <= 3           | Falso      |
| 8    | 8    | 8 >= 8           | Verdadero    |
| 7    | 5    | 7 != 5           | Verdadero     |

### üß† LOS OPERADORES LOGICOS

Estos operadores generalmente se van a utilizan para realizar combinaciones de expresiones
l√≥gicas que usan operadores relacionales.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/b2909759-b2dd-4b25-a4f4-a3f302c86db2)

Estos operadores trabajan sobre un resultado booleano. Es decir, eval√∫an una variable booleana
o el resultado de una operaci√≥n l√≥gica basada en operadores relaciones y act√∫a en consecuencia
seg√∫n las denominadas tablas de verdad.

#### ! Operador L√≥gico NO

Al aplicar el operador no, lo que hace es negar (asignar el valor opuesto) de a. Por lo tanto, el
resultado de no a, ser√° falso.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/2a89462a-4cef-405e-9494-be942187b0ab)

#### && Operador L√≥gico Y (o conjunci√≥n)

El operador Y toma los valores que devuelven las expresiones l√≥gicas a y b; y eval√∫a el resultado
en conjunto. 
As√≠, si tanto a como b son verdaderas, el resultado en conjunto ser√° verdadero, caso contrario
devolver√° falso

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/9ca9620b-aa5b-43bf-bfb3-f3968d06564f)

#### || El Operador L√≥gico O (o disyunci√≥n)

El operador O toma los valores que devuelven las expresiones l√≥gicas a y b; y eval√∫a el resultado
en conjunto.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/f1dd6f48-aaa1-44b3-846b-82d947932092)
##

# üî¥ SEMANA 03
## Estructuras Iterativas

Las estructuras de control iterativas permiten repetir una o varias acciones un n√∫mero espec√≠fico de veces. Dentro de estas estructuras, el bloque de c√≥digo que se repite se conoce como bucle, y cada repetici√≥n se llama iteraci√≥n.

### üìö CONCEPTOS
- Estructura de control iterativa: es un tipo de estructura de control que permite repetir
una o varias acciones (instrucciones o sentencias) un determinado n√∫mero de veces.
- Bucle: se indica con este nombre a la secci√≥n de c√≥digo que se repite. Es decir, dentro
de una estructura de control iterativa hay un bucle, por el cual luego de ejecutar su
√∫ltima instrucci√≥n saltar√° a la primera de cumplirse cierta condici√≥n.
- Iteraci√≥n: Cada repetici√≥n de un bucle se conoce como iteraci√≥n.
- 
Al dise√±ar un bucle, es fundamental responder dos preguntas:
1. ¬øQu√© acciones se repiten?
2. ¬øCu√°ntas veces se deben repetir?

La primera pregunta determina si se necesita una estructura iterativa y qu√© acciones se repiten. La segunda pregunta implica asegurar que el n√∫mero de iteraciones sea finito para evitar bucles infinitos. Es crucial tener un mecanismo que garantice la finalizaci√≥n del bucle.

Por ejemplo, al calcular el factorial de 5 (5!), se realiza el producto de todos los n√∫meros enteros del 1 al 5. Aqu√≠, se ejecuta una operaci√≥n un n√∫mero finito de veces (5 veces) con una condici√≥n de parada clara.


### üìö ESTRUCTURA ITERATIVA MIENTRAS

La estructura iterativa mientras (en ingl√©s while) es aquella en la que el bucle se repite
mientras se cumple una determinada condici√≥n. Cuando se ejecuta la instrucci√≥n mientras,
la primera cosa que sucede es que se eval√∫a la condici√≥n (una expresi√≥n l√≥gica o booleana).
Si el resultado de la evaluaci√≥n devuelve falso, no se ejecutar√° el bucle continuando la ejecuci√≥n
del algoritmo fuera de la estructura mientras (se dice que salta hacia afuera del
fin_mientras). Si la expresi√≥n booleana retorna verdadero, entonces se ejecuta el bucle y
al llegar al final de este se proceder√° a evaluar nuevamente la expresi√≥n booleana.
Por lo tanto, las iteraciones se suceder√°n una tras otra mientras la expresi√≥n booleana
(condici√≥n) siga retornando el valor verdadero. A continuaci√≥n, se esquematiza la estructura de
control iterativa mientras

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/234aabc0-04f3-4df0-8751-0437cd17d846)

### üìë UNA VARIABLE CON OBJETIVO ESPEC√çFICO: EL CONTADOR

Una variable con un prop√≥sito espec√≠fico en estructuras de control iterativas es el contador. El contador se utiliza para rastrear el n√∫mero de iteraciones en un bucle. Su funci√≥n principal es mantener un registro del progreso del bucle, aumentando o disminuyendo su valor en cada iteraci√≥n. Esto permite controlar el n√∫mero de repeticiones y determinar cu√°ndo detener el bucle. El contador es esencial para estructuras como los bucles for y while, donde su valor se actualiza en cada ciclo hasta que se alcanza una condici√≥n de salida espec√≠fica.

### üìö ESTRUCTURA ITERATIVA HACER-MIENTRAS

El bucle mientras eval√∫a la expresi√≥n al comienzo del bucle de repetici√≥n; siempre se utilizan
para crear bucle pre-test. Los bucles pre-test se denominan tambi√©n bucles controlados por la
entrada. En numerosas ocasiones se necesita que el conjunto de sentencias que componen el
cuerpo del bucle se ejecute al menos una vez sea cual sea el valor de la expresi√≥n o condici√≥n
de evaluaci√≥n. 

Estos bucles se denominan bucles post-test o bucles controlados por la salida. Un caso t√≠pico es
el bucle hacer-mientras (do-while).

El bucle hacer-mientras es an√°logo al bucle mientras y el cuerpo del bucle se ejecuta
una y otra vez mientras la condici√≥n (expresi√≥n booleana) sea verdadera. Existe, sin embargo,
una gran diferencia y es que el cuerpo del bucle est√° encerrado entre las palabras reservadas
hacer y mientras, de modo que las sentencias de dicho cuerpo se ejecutan, al menos una
vez, antes de que se eval√∫e la expresi√≥n booleana. En otras palabras, el cuerpo del bucle siempre
se ejecuta, al menos una vez, incluso aunque la expresi√≥n booleana sea falsa.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/31d19624-1db7-4183-b9d7-fab7777497bf)

### üìö ESTRUCTURA ITERATIVA PARA

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/1e79b484-2901-4e93-b6ec-08b16eb26f78)

La estructura del bucle for comienza con un valor inicial (vi) de la variable de √≠ndice (v), y las acciones especificadas se ejecutan mientras el valor inicial sea menor o igual al valor final (vf).
La variable de √≠ndice (vi) se incrementa en uno por defecto, o por un valor mayor seg√∫n lo indicado por incr. Si este nuevo valor no excede el valor final (vf), las acciones se ejecutan nuevamente.
Por lo tanto, las acciones dentro del bucle se repiten para cada valor de la variable de √≠ndice desde el valor inicial hasta el valor final, con el incremento indicado en incr.
El incremento de la variable de √≠ndice suele ser 1 por defecto, pero puede ser diferente, positivo o negativo, seg√∫n lo especificado.
Normalmente, la variable de √≠ndice es de tipo entero y se suelen usar letras como i, j, k como nombres.
El formato de la estructura del bucle for var√≠a si se desea un incremento distinto a 1, ya sea positivo o negativo (decremento).

## ‚å®Ô∏è PROGRAMACI√ìN CON PROCESSING

### üì¶ VARIABLES

Las variables son elementos fundamentales en la computaci√≥n y en la programaci√≥n. Permiten almacenar valores durante la ejecuci√≥n de un programa y pueden modificarse seg√∫n sea necesario. Cada variable est√° asociada a un espacio f√≠sico en la memoria del ordenador, tiene un nombre √∫nico llamado identificador, y puede contener diferentes tipos de datos, como n√∫meros, texto, o valores l√≥gicos.
El identificador de la variable, elegido por el programador, debe ser descriptivo y no puede coincidir con palabras reservadas del lenguaje de programaci√≥n. Por otro lado, el valor almacenado en la variable debe ser definido previamente, es decir, se debe especificar qu√© tipo de dato contendr√° la variable, como n√∫meros enteros, decimales, texto, o valores l√≥gicos.

### üìö TIPOS DE DATOS EN PROCESSING

Processing ofrece varios tipos de datos para almacenar diferentes tipos de informaci√≥n. Estos se dividen en dos categor√≠as principales: primitivos y tipos de referencia. En este momento, nos centraremos en los primitivos.

1. **int**: Representa enteros de 32 bits con un rango desde -2.147.483.648 hasta 2.147.483.647.
2. **float**: Almacena n√∫meros con punto decimal, con un rango desde aproximadamente -3.4 √ó 10^38 hasta 3.4 √ó 10^38.
3. **char**: Permite almacenar caracteres individuales, como letras o s√≠mbolos, en el formato Unicode.
4. **boolean**: Solo puede almacenar dos valores: `TRUE` o `FALSE`, √∫til para controlar el flujo de los programas.
5. **color**: Permite almacenar colores codificados en n√∫meros hexadecimales.

Estos tipos de datos son fundamentales para definir variables y realizar operaciones en programas de Processing. Cada tipo tiene un rango de valores espec√≠fico y se utiliza seg√∫n las necesidades del programa.


### üìñ LAS VARIABLES PREDEFINIDAS (O DEL SISTEMA)

Processing proporciona varias variables predefinidas que pueden ser utilizadas directamente en los programas sin necesidad de declararlas. Estas variables son √∫tiles para obtener informaci√≥n sobre la ventana de trabajo, la interacci√≥n del usuario y otros aspectos del entorno de ejecuci√≥n. Algunas de las variables predefinidas m√°s importantes son:

1. `width`: Almacena el ancho de la ventana de trabajo.
2. `height`: Almacena el alto de la ventana de trabajo.
3. `frameRate`: Guarda la velocidad de ejecuci√≥n del programa.
4. `frameCount`: Contiene el n√∫mero de frames ejecutados desde el inicio del programa.
5. `displayHeight`: Almacena el alto de la pantalla completa.
6. `displayWidth`: Almacena el ancho de la pantalla completa.
7. `key`: Contiene el valor de la tecla recientemente oprimida.
8. `keyCode`: Detecta teclas especiales como flechas o teclas modificadoras.
9. `keyPressed`: Es verdadero si alguna tecla est√° siendo oprimida.
10. `mouseX`: La coordenada horizontal del mouse dentro de la ventana de trabajo.
11. `mouseY`: La coordenada vertical del mouse dentro de la ventana de trabajo.
12. `pmouseX`: La posici√≥n horizontal del mouse en el frame anterior.
13. `pmouseY`: La posici√≥n vertical del mouse en el frame anterior.
14. `mousePressed`: Indica si el bot√≥n del mouse est√° siendo oprimido.
15. `mouseButton`: Detecta qu√© bot√≥n del mouse fue seleccionado.
Estas variables simplifican el desarrollo de programas en Processing al proporcionar informaci√≥n relevante sobre la interacci√≥n del usuario y el entorno de ejecuci√≥n.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/9663e264-976d-4168-97e4-0ba2a9ec934f)


### üìö LAS ESTRUCTURAS DE CONTROL CONDICIONALES

En Processing, las estructuras de control condicionales son herramientas fundamentales para dirigir el flujo de ejecuci√≥n de un programa basado en condiciones espec√≠ficas. Estas estructuras incluyen:

1. **Estructuras Condicionales Simples:**
   - Permiten tomar decisiones basadas en una √∫nica comparaci√≥n.
   - Se utilizan para ejecutar un bloque de c√≥digo si una condici√≥n es verdadera.
   - La sintaxis b√°sica es:
     ```java
     if (condicion) {
         // Bloque de c√≥digo a ejecutar si la condici√≥n es verdadera
     }
     ```

2. **Estructuras Condicionales Dobles:**
   - Permiten elegir entre dos opciones basadas en el cumplimiento de una condici√≥n.
   - Se ejecuta un bloque de c√≥digo si la condici√≥n es verdadera y otro si es falsa.
   - La sintaxis b√°sica es:
     ```java
     if (condicion) {
         // Bloque de c√≥digo a ejecutar si la condici√≥n es verdadera
     } else {
         // Bloque de c√≥digo a ejecutar si la condici√≥n es falsa
     }
     ```

3. **Estructuras Condicionales M√∫ltiples Anidadas:**
   - Permiten evaluar una expresi√≥n contra m√∫ltiples resultados posibles.
   - Se utilizan m√∫ltiples `else if` despu√©s de un `if` para evaluar varias condiciones.
   - La estructura es:
     ```java
     if (condicion1) {
         // Bloque de c√≥digo a ejecutar si la condici√≥n1 es verdadera
     } else if (condicion2) {
         // Bloque de c√≥digo a ejecutar si la condicion2 es verdadera
     } else {
         // Bloque de c√≥digo a ejecutar si ninguna de las condiciones anteriores es verdadera
     }
     ```

Adem√°s, en Processing se utilizan operadores l√≥gicos como `&&` (AND) y `||` (OR) para realizar evaluaciones l√≥gicas combinadas.

### || && ! LOS OPERADORES L√ìGICOS

Los operadores l√≥gicos permiten hacer una evaluaci√≥n unificada, dado un conjunto de
expresiones l√≥gicas. Los operadores l√≥gicos que ofrece Processing son:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/663e1579-896f-422e-9055-ac9864294e3a)

- El &&: La conjunci√≥n es un operador que opera sobre dos valores de verdad.
T√≠picamente los valores de verdad de dos condiciones, devolviendo el valor de verdad
verdadero cuando ambas proposiciones son verdaderas, y falso en cualquier otro caso.
Es decir que es verdadera cuando ambas son verdaderas. La tabla de verdad de la
conjunci√≥n es la siguiente:

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/bbfdcb3d-4eb9-4fbf-a830-31764724ddcb)

- El ||: La disyunci√≥n es un operador que funciona sobre dos valores de verdad,
t√≠picamente los valores de verdad de dos condiciones, devolviendo el valor de verdadero
cuando una de las proposiciones es verdadera, o cuando ambas lo son, y falso cuando
ambas son falsas.

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/3385b998-d52b-470e-889b-049526b5a881)

### üìñ FUNCI√ìN RANDOM

La funci√≥n random() se refiere al proceso de aleatoriedad. Este t√©rmino se asocia a todo proceso
cuyo resultado no es previsible m√°s que por azar. El resultado de todo suceso aleatorio no puede
determinarse en ning√∫n caso antes de que este se produzca. En computaci√≥n, la funci√≥n
random() es capaz de generar un n√∫mero flotante aleatorio dado un rango de valores
proporcionado. 

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/9ca3a43a-d808-4c5f-98ec-4f71cbec2279)

### üîÅ ESTRUCTURA DE CONTROL ITERATIVAS

En cuanto a las estructuras de control iterativas, existen dos principales en Processing:

1. **La Instrucci√≥n `while`:**
   - Permite repetir un bloque de c√≥digo mientras se cumpla una condici√≥n.
   - La estructura b√°sica es:
     ```java
     while (condicion) {
         // Bloque de c√≥digo a repetir mientras la condici√≥n sea verdadera
     }
     ```

2. **La Instrucci√≥n `for`:**
   - Se utiliza cuando se conoce de antemano el n√∫mero de veces que se debe repetir un bloque de c√≥digo.
   - La estructura b√°sica es:
     ```java
     for (inicializaci√≥n; condici√≥n; actualizaci√≥n) {
         // Bloque de c√≥digo a ejecutar mientras se cumpla la condici√≥n
     }
     ```

Estas estructuras de control son esenciales para dirigir el flujo de ejecuci√≥n de un programa y tomar decisiones basadas en condiciones espec√≠ficas. Tambi√©n facilitan la repetici√≥n de bloques de c√≥digo, lo que permite una programaci√≥n m√°s eficiente y estructurada.

##PROGRAMACI√ìN CREATIVA

El avance de las tecnolog√≠as digitales ha impactado en el desarrollo personal y profesional, incluyendo a los artistas y dise√±adores. La integraci√≥n de la programaci√≥n y el arte es esencial en el dise√±o de videojuegos, y aprender programaci√≥n usando herramientas creadas por dise√±adores puede ser beneficioso.

### üß† La programaci√≥n creativa:
La programaci√≥n creativa es un movimiento que establece que los lenguajes de programaci√≥n
se conciben como medios creativos, a la altura de la m√∫sica, la danza o la pintura.
En este enfoque los lenguajes de programaci√≥n son considerados un nuevo est√°ndar
internacional para crear aplicaciones en cualquier parte del mundo y para cualquier parte del
mundo. Esto se torna mucho m√°s visible en el mundo del desarrollo de videojuegos, donde se
mezcla el arte y la programaci√≥n para crear expresiones de sensaciones. Los videojuegos son un
medio para transmitir sensaciones por medio de la inmersi√≥n (la experiencia cierta de poder
expresarse dentro de un mundo ficticio).

### ‚úçÔ∏è El c√≥digo creativo:
El centro de la programaci√≥n creativa es el c√≥digo creativo, donde el c√≥digo de la computadora se trata como un medio creativo natural. La forma en que se resuelve un problema es tan importante como la soluci√≥n en s√≠ misma. La programaci√≥n creativa utiliza bases de matem√°ticas, f√≠sica, computaci√≥n y teor√≠a art√≠stica para encontrar soluciones interesantes y novedosas.

El centro de la programaci√≥n creativa es el c√≥digo creativo, el cual se define como

**`ùëê√≥ùëëùëñùëîùëú ùëêùëüùëíùëéùë°ùëñùë£ùëú = ùëéùëüùë°ùëí + ùëêùëñùëíùëõùëêùëña`**

### Combatir prejuicios:
La programaci√≥n creativa busca combatir prejuicios sobre las ciencias de la computaci√≥n, promoviendo el "aprendizaje haciendo" a trav√©s de la construcci√≥n de bocetos de c√≥digo creativo. Se desaf√≠a la idea de  que sostienen que las mismas son dif√≠ciles, aburridas y oscuras o solo para ciertos tipos de personas, y se fomenta la exploraci√≥n creativa y el descubrimiento en el proceso de aprendizaje.

### üìö QUE ES PROCESSING

**Es un entorno de programaci√≥n open source (c√≥digo abierto) basado en el lenguaje de programaci√≥n Java para gente creativa. La premisa es que no es necesario que estas personas**

### üí°ENFOQUE PEDAG√ìGICO CON PROCESSING

Processing fue creado para ense√±ar los fundamentos
de la programaci√≥n computacional dentro de un
contexto visual para servir como software de bocetos
y ser usado como herramienta de producci√≥n.

El modelo de bocetos de la herramienta es totalmente
compatible con el modelo de conceptos que se utiliza
para dise√±ar videojuegos; por lo cual resulta apropiado
para la ense√±anza de los principios b√°sicos de la
programaci√≥n. Y es que resulta que el documento de
conceptos es la primera referencia del juego para el
equipo de desarrollo. En √©l detallamos la visi√≥n general del juego y nos permitir√° tener una idea
clara de los objetivos que queremos alcanzar.
## 

# üü° SEMANA 04
## üß† CONCEPTO PARADIGMA
El estadounidense **Thomas Kuhn**, los define como:

**`La serie de pr√°cticas que trazan los lineamientos de una disciplina cient√≠fica a lo largo de un cierto lapso temporal. El √©xito de un paradigma es consecuencia de su efectividad para resolver alg√∫n problema.`**

Las pr√°cticas hacen referencia a:

- **Las leyes establecidas y los supuestos te√≥ricos.** Por ejemplo, las leyes de movimiento
de Newton forman parte del paradigma newtoniano y las ecuaciones de Maxwell
forman parte del paradigma que constituye la teor√≠a electromagn√©tica cl√°sica.

- **El instrumental y las t√©cnicas instrumentales** necesarias para hacer que las leyes del
paradigma se refieran al mundo real. La aplicaci√≥n en astronom√≠a del paradigma
newtoniano requiere el uso de diversos telescopios, junto con t√©cnicas para su
utilizaci√≥n y diversas t√©cnicas para corregir los datos recopilados.

- **Los principios generales propios** del paradigma que gu√≠an el trabajo dentro del
paradigma. Por ejemplo, para construir una un puente, se deben seguir ciertos pasos,
medidas y m√©todos preestablecidos para garantizar que el trabajo se realice de manera
correcta.

Respecto del **lapso temporal**, se hace referencia a que los paradigmas son el resultado de un proceso social en el que un grupo de individuos desarrolla nuevas ideas y establece principios y pr√°cticas en torno a esas ideas. Se destaca que un paradigma puede ser efectivo para explicar ciertos aspectos del mundo, pero puede ser inaplicable u obsoleto para otros fen√≥menos, lo que sugiere la posible existencia de otros paradigmas m√°s adecuados. Este fen√≥meno se interpreta como una consecuencia natural del proceso de evoluci√≥n o maduraci√≥n del concepto. Se ilustra este punto con un ejemplo en la programaci√≥n de videojuegos, donde se plantea que pueden existir m√∫ltiples paradigmas aplicables y que algunos pueden ser m√°s adecuados que otros para diferentes tipos de problemas.

En las ciencias sociales, un paradigma se utiliza
para explicar la forma en que se entiende el
mundo. Se emplea para mencionar a todas
aquellas experiencias, creencias, vivencias y
valores que repercuten y condicionan el modo en
que una persona ve la realidad y act√∫a en funci√≥n
de ello.

De esta manera para brindar una definici√≥n formal, se considera paradigma a:
- Los marcos de referencia que imponen reglas sobre c√≥mo se deben hacer las cosas,
indican qu√© es v√°lido dentro del paradigma y qu√© est√° fuera de sus l√≠mites. Un paradigma
distinto implica nuevas reglas, elementos, l√≠mites y maneras de pensar, o sea implica un
cambio.
- Patrones de pensamiento para la resoluci√≥n de problemas. Un modelo o esquema
fundamental que organiza nuestras opiniones con respecto a alg√∫n tema en particular.
Los paradigmas establecen l√≠mites adoptados por los miembros de una comunidad
cient√≠fica para resolver problemas sustentados por los principios, leyes, supuestos
te√≥ricos y t√©cnicas que la conforman.

### üóÉÔ∏è ELEMENTOS DE LOS PARADIGMAS
Sin entrar en detalles, los paradigmas se sustentan en teor√≠as, creencias, valores, leyes, t√©cnicas
e hip√≥tesis. Debido a esta formalidad, este √∫ltimo esquema intenta diferenciar conceptos que
normalmente son confundidos con paradigmas

![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/84463e50-2918-4da4-9384-4b840e39168e)



### üìö PARADIGMAS DE PROGRAMACI√ìN
## üìöüìö Caracteristicas de PARADIGMAS: 

`**1ra Caracter√≠stica de paradigma:** Los objetos son contenedores de la
informaci√≥n y la funcionalidad que se pueden programar.`

`**2da Caracter√≠stica del Paradigma:** Los objetos interact√∫an, colaborando
para que el programa cumpla su objetivo.`

 `**3ra Caracter√≠stica del Paradigma:** Los
objetos se crean a partir¬†de¬†clases.`


Existen diferentes concepciones para los paradigmas de programaci√≥n:

- **Un proceso de dise√±o que va m√°s all√° de una
gram√°tica, reglas sem√°nticas y algoritmos.** Es un
conjunto de m√©todos sistem√°ticos aplicables en
todos los niveles del dise√±o de programas.
Representan un enfoque particular o filosof√≠a
para la construcci√≥n del software.

- **Son propuestas tecnol√≥gicas adoptadas por la
comunidad de desarrolladores que se enfocan a
resolver uno o varios problemas definidos y
delimitados.**

- **Es un modelo b√°sico de dise√±o y desarrollo de programas, que permite producir
programas con unas directrices espec√≠ficas**, tales como: estructura modular, fuerte
cohesi√≥n, alta rentabilidad, etc.

- **Es una colecci√≥n de modelos conceptuales que en conjunto modelan el proceso de
dise√±o y determinan la estructura de un programa.** Esa estructura conceptual de
modelos est√° pensada de forma que los modelos determinan la forma correcta de los
programas y controlan el modo en que el desarrollador piensa y formula soluciones, que
luego son implementadas en un lenguaje de programaci√≥n.

- **Provee y determina la visi√≥n y m√©todos de un programador en la construcci√≥n de un
programa o subprograma.** Diferentes paradigmas resultan en diferentes estilos de
programaci√≥n y en diferentes formas de pensar la soluci√≥n de problemas (con la
soluci√≥n de m√∫ltiples ‚Äúproblemas‚Äù se construye una aplicaci√≥n o producto de software).

Existen tres cuestiones para tener en cuenta respecto de los paradigmas de programaci√≥n:

1. Ning√∫n paradigma es mejor que otro, sino que cada uno tiene ventajas y desventajas.
Tambi√©n hay situaciones donde un paradigma resulta m√°s apropiado que otro.
2. Para que las caracter√≠sticas esenciales del paradigma sean efectivamente aplicadas, las
caracter√≠sticas del lenguaje de programaci√≥n utilizado para implementar la aplicaci√≥n
deben reflejar adecuadamente los modelos conceptuales de ese paradigma. Cuando un
lenguaje refleja bien un paradigma particular, se dice que soporta el paradigma, y en la
pr√°ctica un lenguaje que soporta correctamente un paradigma, es dif√≠cil distinguirlo del
propio paradigma.
3. Los lenguajes de programaci√≥n est√°n basados en uno o m√°s paradigmas, por ejemplo:
Processing est√° basado en el paradigma orientado a objetos. El lenguaje de
programaci√≥n Scheme, en cambio, soporta solo programaci√≥n funcional. Otros
lenguajes, como C++ y Python soportan m√∫ltiples paradigmas.

### üòÉ EL PARADIGMA ORIENTADO A OBJETOS DE MANERA RESUMIDA

El paradigma de programaci√≥n orientada a objetos, que se fundamenta en la idea de representar problemas y soluciones de manera similar al procesamiento de informaci√≥n del cerebro humano. En este paradigma, los problemas y soluciones se representan como entidades llamadas objetos, que poseen atributos almacenados en variables especiales y operaciones que act√∫an sobre esos atributos mediante algoritmos espec√≠ficos.

Los objetos se comunican entre s√≠ a trav√©s de mensajes, estableciendo relaciones seg√∫n un conjunto de reglas y normas definidas en el protocolo de mensajes. Este paradigma se sustenta en cuatro pilares:** abstracci√≥n, encapsulaci√≥n, herencia y polimorfismo.** Estos pilares estructuran la creaci√≥n, uso y destrucci√≥n de objetos mediante clases, y establecen un contrato entre clases para la implementaci√≥n de operaciones. Adem√°s, definen formalmente qu√© es un objeto, c√≥mo se modelan y c√≥mo se optimiza la reusabilidad y mantenimiento del c√≥digo.

### ‚úçÔ∏è EL MODELADO Y LA ABSTRACCI√ìN EN EL PARADIGMA ORIENTADO A OBJETOS

El modelado es una t√©cnica que consiste en
representar informaci√≥n mediante un modelo. Un
modelo es una abstracci√≥n de una realidad. El
t√©rmino abstracci√≥n hace referencia al proceso de
centrarse √∫nicamente en los detalles relevantes del
fen√≥meno estudiado o que es objeto de
observaci√≥n.
La abstracci√≥n es tambi√©n, una de las propiedades del paradigma orientado a objetos; esto
significa que el paradigma orientado a objetos buscar√° a trav√©s de esta propiedad:

- Abstraer un problema (determinar los aspectos relevantes del problema resolver) para
luego realizar una,
- abstracci√≥n de la soluci√≥n de ese problema (determinar los aspectos relevantes de la
soluci√≥n que se propone como soluci√≥n al problema) y finalmente
- construir una abstracci√≥n del sistema inform√°tico creado. Esto significa que los aspectos
relevantes del producto sean programados, probados y documentados en la forma de
clases y sus interrelaciones, para que otros desarrolladores puedan interpretarlos.

### üß† CARACTERISTICAS DEL MODELADO
El modelado ofrece 4 caracter√≠sticas esenciales:

1) Una visualizaci√≥n de un sistema: tanto del
problema a solucionar como de la soluci√≥n. En
ambos casos estamos refiri√©ndonos a una
aproximaci√≥n (en el primer caso una
aproximaci√≥n de los objetos de nuestro juego y
como ellos interact√∫an, mientras que del
segundo caso un esquema y documentaci√≥n del software del videojuego)
2) Una especificaci√≥n de su comportamiento: nos permite indicar detalladamente como
act√∫a el mismo ante diferentes situaciones.
3) Una plantilla que gu√≠e a los desarrolladores durante su construcci√≥n: es decir son los
‚Äúplanos‚Äù que el arquitecto del software sigue para construir el producto.
4) Documentar decisiones de dise√±o: siempre las decisiones de dise√±o deben estar bien
documentadas y justificadas. En algunas metodolog√≠as la documentaci√≥n se dejaba al
√∫ltimo; o como sucede de forma muy habitual est√° la tentaci√≥n de no documentar por
el tiempo que incurre. Los modelos permiten minimizar el tiempo de documentaci√≥n. 

### üß†üß† LOS ELEMENTOS CENTRALES DE LA ABSTRACCI√ìN DE OBJETOS

El modelo orientado a objetos permite construir una representaci√≥n para analizar, describir,
explicar simular o predecir un fen√≥meno y se sustenta alrededor de las siguientes definiciones:
- **Clase:** modelo, molde, plano o maqueta a partir del cual se pueden generar objetos. Las
clases son entidades utilizadas para analizar el problema y dise√±ar la soluci√≥n. Toda clase
posee 3 elementos importantes: el nombre de la clase, los atributos y las operaciones. Mediante las clases se pueden determinar los actores (clases) que participan en el
problema estudiado (o en la soluci√≥n) as√≠ como las caracter√≠sticas y acciones que estas
entidades poseen y que contribuyen de alguna manera para que se cumplan los
objetivos abordados por la soluci√≥n planteada (los requisitos). Las clases son
programadas en un lenguaje de programaci√≥n orientado a objetos.

- **Objeto**: Los programas se ejecutan en memoria, adoptando el nombre de procesos. En
el caso de los programas orientados a objetos estos procesos se denominan objetos que
adquieren los atributos y operaciones de la clase a partir de la cual se ha creado, de esta
manera en memoria pueden existir muchos objetos generados a partir de la misma clase
pero cada una con su propia identidad que la separa de las dem√°s (esto puede
asemejarse al hecho de que a partir de un mismo plano se pueden construir varias
viviendas, todas iguales por las especificaciones del plano pero en definitiva cada una
es una construcci√≥n individual)
- **Relaciones:** Indica la forma en que los objetos colaboran entre ellos para realizar alguna
tarea espec√≠fica. Esto genera un nuevo concepto que es el mensaje: es el mecanismo
por el cual un objeto en memoria solicita a otro que ejecute una operaci√≥n. Entonces
las relaciones indican la forma en que los objetos env√≠an mensajes a otros objetos.
- **Interfaz:** Las operaciones de un objeto que pueden ser solicitadas por otro objeto se
denominan servicios. Para que los servicios de un objeto puedan ser invocados por otro
objeto; el objeto que desea ponerlos a disposici√≥n de los otros objetos debe definir una
interfaz. La interfaz es simplemente un mecanismo por el cual se determina si una
operaci√≥n se halla disponible para ser invocada por otro objeto (las operaciones dentro
del objeto siempre son servicios para las otras operaciones del mismo objeto, esto es,
las operaciones de un objeto siempre pueden ser invocadas por las otras operaciones
del mismo objeto). El concepto de interfaz tambi√©n se aplica a los atributos, esto es; si
no se especifica una interfaz para un atributo, el mismo no podr√° estar disponible para
otros objetos.

## LA ABSTRACCI√ìN DE LAS CLASES 

**Introducci√≥n a la abstracci√≥n en el paradigma orientado a objetos**

La abstracci√≥n, piedra angular del paradigma orientado a objetos, es un proceso crucial para identificar las caracter√≠sticas esenciales y los comportamientos comunes de una parte de la realidad. Este proceso permite definir las entidades que representan el sistema estudiado y es fundamental en el an√°lisis y dise√±o orientado a objetos, ya que facilita la determinaci√≥n de las clases que modelan el problema a resolver.

### **La importancia de la clase como entidad fundamental**

La clase, entendida como una entidad que describe un conjunto de objetos con estructura y comportamiento similares, es un concepto central en la programaci√≥n orientada a objetos. Se asemeja a un "molde" del cual se pueden crear m√∫ltiples objetos del sistema inform√°tico. Esta analog√≠a con los moldes para hornear ilustra c√≥mo las clases permiten obtener objetos con caracter√≠sticas espec√≠ficas.

### **Principio de abstracci√≥n: distinci√≥n, focalizaci√≥n y clasificaci√≥n**

El principio de abstracci√≥n en el paradigma orientado a objetos se basa en tres premisas fundamentales: distinguir diferentes objetos, focalizarse en las caracter√≠sticas y operaciones esenciales de esos objetos, y clasificar los objetos en base a sus caracter√≠sticas y operaciones comunes en clases. Este principio refleja un proceso natural que todos aplicamos en nuestra vida cotidiana al diferenciar entre diversos tipos de objetos y enfocarnos en sus propiedades esenciales.

**Aplicaci√≥n del principio de abstracci√≥n en situaciones cotidianas**

Desde la infancia, aprendemos a clasificar objetos y a distinguir entre ellos. Ya sea diferenciando entre seres vivos y objetos inanimados o identificando herramientas y juguetes, ejercemos la capacidad de abstracci√≥n de manera intuitiva. Adem√°s, en nuestras actividades diarias, como practicar un deporte, aplicamos la abstracci√≥n al centrarnos en las propiedades esenciales comunes de los objetos involucrados, como compa√±eros de equipo, pelotas y objetivos del juego.

**Importancia de la abstracci√≥n en el desarrollo de videojuegos**

La abstracci√≥n juega un papel crucial en el desarrollo de videojuegos. Cada elemento de un juego, desde personajes hasta objetos y entornos, se representa mediante clases que definen su estructura y comportamiento. Estas clases son la base para la creaci√≥n de los GameObjects, que son los objetos individuales en el juego.

**Ejemplo pr√°ctico: identificaci√≥n de clases en una pantalla de juego**

En una pantalla de juego, cada elemento visible est√° respaldado por clases que representan su funcionalidad y apariencia. Al identificar estas clases junto con sus atributos y operaciones, podemos entender c√≥mo se generan los GameObjects y c√≥mo interact√∫an en el juego.

### **Modelado de la abstracci√≥n: Introducci√≥n al Diagrama de Clases en UML**

El modelado de la abstracci√≥n de objetos se lleva a cabo mediante el uso de diagramas estandarizados, siendo el Diagrama de Clases de UML (Unified Modeling Language) uno de los m√°s prominentes. Este diagrama es fundamental para especificar la estructura de datos de un sistema de informaci√≥n en el √°mbito del modelado orientado a objetos.

### üë™ **Familias de Diagramas en UML**

UML ofrece dos grandes familias de diagramas: los diagramas de estructuras y los diagramas de comportamiento. Los primeros se centran en la arquitectura de datos del sistema, mientras que los segundos se enfocan en especificar su comportamiento.

### üóÉÔ∏è **Diagramas de Clase: Aspectos Generales**

El Diagrama de Clases es esencial en UML, ya que se utiliza principalmente para definir la estructura de datos de un sistema. Este diagrama constituye la base de cualquier soluci√≥n en el modelado orientado a objetos, ya que incluye el conjunto de clases que conforman la estructura b√°sica del sistema y distribuye los datos que maneja a trav√©s de sus atributos.

An√°logamente al cuerpo humano, donde las clases y sus atributos representan el esqueleto del sistema, el Diagrama de Clases tambi√©n permite definir los "m√∫sculos" que permiten la movilidad del sistema, es decir, las operaciones y relaciones entre clases que determinan su funcionamiento.

### üìñ **Representaci√≥n de Clases en UML**

En un Diagrama de Clases, una clase se representa como una caja que puede dividirse en una, dos o tres partes. La primera parte siempre indica el nombre de la clase. Si la clase se divide en tres secciones, la segunda parte corresponde a los atributos y la tercera a las operaciones. En caso de que la clase solo tenga dos secciones, la segunda puede referirse tanto a los atributos como a las operaciones.

**Ejemplo Pr√°ctico: Clase Avi√≥n en UML**

Para ilustrar este concepto, consideremos la clase Avi√≥n. En el diagrama, se representa expl√≠citamente las tres partes de la clase: nombre (Avi√≥n), atributos (modelo, cantidad de motores, velocidad y capacidad) y operaciones (acelerar y girar en una direcci√≥n). Este ejemplo muestra c√≥mo se modela una clase en UML y c√≥mo se pueden definir objetos a partir de ella.


![image](https://github.com/AlexUnju/apunteResumenFpoo/assets/142057928/c28c85d4-6b14-4101-a3a3-c4c860ec2e6d)


**En conclusi√≥n, el Diagrama de Clases en UML es una herramienta fundamental para el modelado de la abstracci√≥n en la programaci√≥n orientada a objetos, permitiendo representar la estructura de datos de un sistema y definir sus relaciones y comportamientos de manera clara y concisa.**

### üìèüìè **Nomenclatura para la Definici√≥n de Nombres de Clases**

1. Los nombres de las clases deben ser sustantivos en singular.
2. La primera letra del nombre debe comenzar en may√∫scula, seguida de letras min√∫sculas.
3. No se permiten espacios en los nombres. Durante la fase de an√°lisis en UML, se puede usar guion bajo (_) para separar palabras en el nombre de la clase. Sin embargo, durante la fase de dise√±o, es una pr√°ctica com√∫n que la primera letra de cada palabra subsecuente est√© en may√∫scula. Esta √∫ltima recomendaci√≥n se aplicar√° en todos los diagramas de clases realizados en la asignatura.

**Caracter√≠sticas Avanzadas de una Clase: Visibilidad**

Adem√°s de los elementos b√°sicos como el nombre, atributos y operaciones, una clase tambi√©n cuenta con propiedades avanzadas que permiten especificar aspectos m√°s detallados de la clase modelada. Entre estas propiedades, la visibilidad es fundamental, ya que determina el acceso que otras clases tendr√°n a los atributos y operaciones de la clase.

**Definici√≥n de Visibilidad**

La visibilidad establece la disponibilidad que ofrece una clase a otras clases en cuanto al uso o acceso de sus atributos y operaciones. Se puede especificar si un atributo u operaci√≥n est√° totalmente disponible para otras clases, o si est√° restringido y no disponible para ninguna otra clase. Adem√°s, existen niveles intermedios de visibilidad que pueden variar seg√∫n el lenguaje de programaci√≥n utilizado.

### üéöÔ∏è **Niveles de Visibilidad en UML**

En UML, se definen cuatro niveles de visibilidad:

1. **P√∫blico (+)**: La visibilidad se extiende a otras clases, lo que significa que cualquier clase puede acceder a ese atributo u operaci√≥n.

2. **Protegido (#)**: La visibilidad se extiende √∫nicamente a las subclases de la clase original. Esto se profundizar√° m√°s adelante cuando se aborde el concepto de herencia.

3. **Privado (-)**: En este nivel, solo la clase original puede acceder a los atributos y operaciones privadas.

4. **Paquete (~)**: Introducido en UML 2.5 para reflejar pr√°cticas de algunos lenguajes de programaci√≥n. La visibilidad se extiende a las clases que comparten el mismo paquete en el que se ha definido la clase original. Fuera de este paquete, otras clases no pueden acceder al atributo u operaci√≥n a menos que sean subclases.


### üìí **Definici√≥n de Atributos en UML**

La definici√≥n de un atributo en UML implica considerar varios aspectos para una descripci√≥n completa y precisa. Un atributo representa una caracter√≠stica espec√≠fica de un objeto y es, en esencia, una variable que almacena un valor. Para una representaci√≥n adecuada en UML, es esencial comprender los tipos de datos predefinidos que ofrece UML y c√≥mo se aplican en la definici√≥n de atributos. A continuaci√≥n, se presentan los tipos de datos predefinidos en UML, junto con ejemplos de su uso:

1. **Boolean**: Indica un valor l√≥gico que puede ser verdadero o falso. Ejemplo: `isFinishedTime: boolean`

2. **Byte**: Representa un tipo num√©rico para enteros con un rango limitado, generalmente entre -128 y 127. Ejemplo: `cantidadVidas: byte`

3. **Short**: Indica un tipo num√©rico para enteros con un rango m√°s amplio que Byte. Ejemplo: `puntajeBonus: short`

4. **Integer**: Representa un tipo num√©rico para enteros con rangos muy grandes. Ejemplo: `puntajeAcumulado: integer`

5. **Long**: Indica un tipo num√©rico para enteros mucho m√°s grandes que Integer, t√≠picamente utilizado en c√°lculos cient√≠ficos. Ejemplo: `distanciaAsaturno: long`

6. **Float**: Representa un tipo num√©rico para n√∫meros reales, √∫til para aplicaciones de videojuegos que manipulan decimales. Ejemplo: `resultadoOperacion: float`

7. **Double**: Indica un tipo num√©rico para n√∫meros reales muy grandes, com√∫nmente utilizado en c√°lculos cient√≠ficos. Ejemplo: `derivada: double`

8. **Date**: Representa un tipo para valores que representan fechas. Ejemplo: `fecNac: date`

9. **String**: Indica un tipo que representa cadenas de caracteres, √∫tiles para almacenar texto. Ejemplo: `Nacionalidad: string`

10. **Char**: Representa un √∫nico car√°cter. Ejemplo: `teclaSeleccionada: char`

Al definir atributos en UML, es esencial considerar el tipo de dato adecuado para cada caracter√≠stica del objeto que se est√° modelando, garantizando as√≠ una representaci√≥n precisa y coherente del sistema.

### üìê **Nomenclatura para la Definici√≥n de Atributos**

La nomenclatura adoptada para la definici√≥n de atributos en esta materia sigue las convenciones del lenguaje de programaci√≥n Java. A continuaci√≥n, se describen las reglas que se aplicar√°n:

1. Los atributos deben iniciar con una letra min√∫scula.
2. No pueden comenzar con un n√∫mero.
3. El nombre del atributo debe reflejar claramente el significado de la caracter√≠stica que representa en la clase. Por ejemplo, para una clase `NaveEspacial` que tiene un atributo que indica la cantidad de vidas, un nombre v√°lido para el atributo ser√≠a `cantVidas`, mientras que nombres como `v` o `cv` ser√≠an inv√°lidos.
4. No se permiten espacios en los nombres de los atributos. En la fase de an√°lisis del Diagrama de Clases, se admite el uso de guion bajo (_), pero en la fase de dise√±o se seguir√° la convenci√≥n de que la primera letra de cada palabra subsiguiente est√© en may√∫scula.

## üìö **Definici√≥n de Operaciones**

Las operaciones representan acciones que pueden ser realizadas por los objetos creados a partir de una clase. La nomenclatura para la definici√≥n de operaciones en esta materia sigue las convenciones del lenguaje Java:

1. Las operaciones deben ser verbos en infinitivo.
2. Se escriben en min√∫scula.
3. No se admiten espacios en los nombres de las operaciones. En la fase de an√°lisis del Diagrama de Clases, se admite el uso de guion bajo (_), pero en la fase de dise√±o se seguir√° la convenci√≥n de que la primera letra de cada palabra subsiguiente est√© en may√∫scula.

En un diagrama de clases, las operaciones se definen siguiendo la sintaxis:

\[visibilidad\] nombre ([lista de par√°metros])[:tipo de retorno]

Los corchetes indican que estos elementos son opcionales, por lo que solo el nombre de la operaci√≥n es requerido.
